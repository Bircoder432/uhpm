############### config.rs #########################
//! # Configuration Module
//!
//! This module defines the configuration structure for UHPM (Universal Home Package Manager).
//! It handles loading, saving, and managing configuration settings including repository URLs
//! and update sources.

use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
use thiserror::Error;

/// Errors that may occur while working with configuration.
#[derive(Error, Debug)]
pub enum ConfigError {
    /// Filesystem error.
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    /// RON parsing error.
    #[error("RON parse error: {0}")]
    Ron(#[from] ron::error::SpannedError),

    /// RON error.
    #[error("RON error: {0}")]
    RonError(#[from] ron::Error),

    /// Configuration file not found.
    #[error("Configuration file not found: {0}")]
    NotFound(String),
}

/// Represents the UHPM configuration.
///
/// Contains settings for package management including update sources
/// and repository configuration.
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct Config {
    /// URL source for UHPM updates
    pub update_source: String,
}

impl Config {
    /// Creates a new configuration with default values.
    pub fn new() -> Self {
        Self {
            update_source: String::new(),
        }
    }

    /// Loads configuration from the default location (`~/.uhpm/config.ron`).
    pub fn load() -> Result<Self, ConfigError> {
        let config_path = Self::get_config_path()?;
        Self::load_from_path(&config_path)
    }

    /// Loads configuration from a specific path.
    pub fn load_from_path<P: AsRef<Path>>(path: P) -> Result<Self, ConfigError> {
        let path_ref = path.as_ref();
        if !path_ref.exists() {
            return Err(ConfigError::NotFound(
                path_ref.to_string_lossy().to_string(),
            ));
        }

        let content = fs::read_to_string(path_ref)?;
        let config: Config = ron::from_str(&content)?;
        Ok(config)
    }

    /// Saves configuration to the default location (`~/.uhpm/config.ron`).
    pub fn save(&self) -> Result<(), ConfigError> {
        let config_path = Self::get_config_path()?;
        self.save_to_path(&config_path)
    }

    /// Saves configuration to a specific path.
    pub fn save_to_path<P: AsRef<Path>>(&self, path: P) -> Result<(), ConfigError> {
        let path_ref = path.as_ref();

        // Create directory if it doesn't exist
        if let Some(parent) = path_ref.parent() {
            fs::create_dir_all(parent)?;
        }

        let pretty = ron::ser::PrettyConfig::new();
        let ron_str = ron::ser::to_string_pretty(self, pretty)?;
        fs::write(path_ref, ron_str)?;

        Ok(())
    }

    /// Returns the default configuration path (`~/.uhpm/config.ron`).
    pub fn get_config_path() -> Result<PathBuf, ConfigError> {
        let home_dir = dirs::home_dir()
            .ok_or_else(|| ConfigError::NotFound("Home directory not found".to_string()))?;

        let mut config_path = home_dir;
        config_path.push(".uhpm");
        config_path.push("config.ron");

        Ok(config_path)
    }

    /// Creates a default configuration file if it doesn't exist.
    pub fn ensure_default() -> Result<(), ConfigError> {
        let config_path = Self::get_config_path()?;

        if !config_path.exists() {
            let default_config = Config::new();
            default_config.save()?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_config_creation() {
        let config = Config::new();
        assert!(config.update_source.is_empty());
    }

    #[test]
    fn test_config_serialization() {
        let mut config = Config::new();
        config.update_source = "https://example.com/updates".to_string();

        let tmp_dir = tempdir().unwrap();
        let config_path = tmp_dir.path().join("config.ron");

        config.save_to_path(&config_path).unwrap();

        let loaded_config = Config::load_from_path(&config_path).unwrap();
        assert_eq!(loaded_config.update_source, "https://example.com/updates");
    }

    #[test]
    fn test_config_not_found() {
        let tmp_dir = tempdir().unwrap();
        let non_existent_path = tmp_dir.path().join("nonexistent.ron");

        let result = Config::load_from_path(&non_existent_path);
        assert!(matches!(result, Err(ConfigError::NotFound(_))));
    }
}
############### ENDOFFILE ########################

############### db.rs #########################
//! # Package Database (`PackageDB`)
//!
//! This module provides an abstraction layer over an SQLite database used
//! by **UHPM (Universal Home Package Manager)** to track installed packages,
//! their versions, installed files, and dependencies.
//!
//! ## Responsibilities
//! - Initialize and maintain the SQLite database schema.
//! - Add, update, and remove package records.
//! - Track installed files and dependencies.
//! - Query package information, including versions and current package state.
//!
//! ## Tables
//! - **`packages`**
//!   - Stores package metadata (name, version, author, source, checksum).
//!   - Marks which version is currently active via the `current` column.
//!
//! - **`installed_files`**
//!   - Maps installed package files to their owning package.
//!
//! - **`dependencies`**
//!   - Tracks package dependencies by name and version.
//!
//! ## Example
//! ```rust,no_run
//! use uhpm::db::PackageDB;
//! use std::path::Path;
//!
//! # tokio_test::block_on(async {
//! let db = PackageDB::new(Path::new("/tmp/uhpm.db"))
//!     .unwrap()
//!     .init()
//!     .await
//!     .unwrap();
//!
//! let packages = db.list_packages().await.unwrap();
//! println!("Installed packages: {:?}", packages);
//! # });
//! ```

use crate::package::{Package, Source};
use crate::{debug, info};
use semver::Version;
use sqlx::Row;
use sqlx::SqlitePool;
use std::fs;
use std::path::{Path, PathBuf};

/// Represents the UHPM package database.
///
/// Internally, this is an SQLite database stored on disk,
/// providing structured access to package metadata.
pub struct PackageDB {
    pool: SqlitePool,
    path: PathBuf,
}

impl PackageDB {
    /// Creates a new `PackageDB` instance and ensures the database file exists.
    ///
    /// This does **not** establish a connection yet.
    ///
    /// # Arguments
    /// - `path`: Path to the SQLite database file.
    ///
    /// # Errors
    /// Returns [`std::io::Error`] if the file or directories cannot be created.
    pub fn new(path: &Path) -> Result<Self, std::io::Error> {
        debug!("db.new.creating", path);

        if !path.exists() {
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent)?;
            }
            std::fs::File::create(path)?;
            debug!("db.new.file_created", path);
        }

        // Placeholder pool, replaced later in `init`
        Ok(PackageDB {
            pool: SqlitePool::connect_lazy("sqlite::memory:")
                .expect("lazy pool must work for placeholder"),
            path: path.to_path_buf(),
        })
    }

    /// Establishes a real database connection and initializes tables if needed.
    ///
    /// # Errors
    /// Returns [`sqlx::Error`] if the database connection or table creation fails.
    pub async fn init(mut self) -> Result<Self, sqlx::Error> {
        let path_str = self.path.to_str().expect("Invalid UTF-8 path");
        let db_url = format!("sqlite://{}", path_str);
        debug!("db.init.connecting", &db_url);

        self.pool = SqlitePool::connect(&db_url).await?;

        debug!("db.init.ensuring_tables");
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS packages (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                version TEXT NOT NULL,
                author TEXT NOT NULL,
                src TEXT NOT NULL,
                checksum TEXT NOT NULL,
                current BOOLEAN NOT NULL DEFAULT 0
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS installed_files (
                package_name TEXT NOT NULL,
                file_path TEXT NOT NULL,
                PRIMARY KEY(package_name, file_path)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS dependencies (
                package_name TEXT NOT NULL,
                dependency_name TEXT NOT NULL,
                dependency_version TEXT NOT NULL,
                PRIMARY KEY(package_name, dependency_name)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        info!("db.init.success", &self.path);
        Ok(self)
    }

    /// Returns a reference to the connection pool.
    pub fn pool(&self) -> &SqlitePool {
        &self.pool
    }

    /// Adds or replaces a package entry in the database (without files or dependencies).
    pub async fn add_package(&self, pkg: &Package) -> Result<(), sqlx::Error> {
        debug!("db.add_package.adding", pkg.name(), pkg.version());
        sqlx::query(
            "INSERT OR REPLACE INTO packages (name, version, author, src, checksum, current) VALUES (?, ?, ?, ?, ?, 0)"
        )
        .bind(&pkg.name())
        .bind(&pkg.version().to_string())
        .bind(&pkg.author())
        .bind(&pkg.src().as_str())
        .bind(&pkg.checksum())
        .execute(&self.pool)
        .await?;
        debug!("db.add_package.added", pkg.name());
        Ok(())
    }

    /// Adds a package with its dependencies and installed files.
    pub async fn add_package_full(
        &self,
        pkg: &Package,
        installed_files: &[String],
    ) -> Result<(), sqlx::Error> {
        info!(
            "db.add_package_full.adding",
            pkg.name(),
            pkg.version(),
            installed_files.len()
        );

        self.add_package(pkg).await?;

        // Dependencies
        for (dep_name, dep_version) in pkg.dependencies() {
            debug!(
                "db.add_package_full.adding_dependency",
                &dep_name, &dep_version
            );
            sqlx::query(
                "INSERT OR REPLACE INTO dependencies (package_name, dependency_name, dependency_version) VALUES (?, ?, ?)"
            )
            .bind(&pkg.name())
            .bind(dep_name)
            .bind(&dep_version.to_string())
            .execute(&self.pool)
            .await?;
        }

        // Installed files
        for file_path in installed_files {
            debug!("db.add_package_full.adding_file", file_path);
            sqlx::query(
                "INSERT OR REPLACE INTO installed_files (package_name, file_path) VALUES (?, ?)",
            )
            .bind(&pkg.name())
            .bind(file_path)
            .execute(&self.pool)
            .await?;
        }

        info!("db.add_package_full.success", pkg.name());
        Ok(())
    }

    /// Returns all files installed by a package.
    pub async fn get_installed_files(&self, pkg_name: &str) -> Result<Vec<String>, sqlx::Error> {
        debug!("db.get_installed_files.fetching", pkg_name);
        let rows = sqlx::query("SELECT file_path FROM installed_files WHERE package_name = ?")
            .bind(pkg_name)
            .fetch_all(&self.pool)
            .await?;

        let files: Vec<String> = rows
            .into_iter()
            .map(|row| row.get::<String, _>("file_path"))
            .collect();
        debug!("db.get_installed_files.found", files.len(), pkg_name);
        Ok(files)
    }

    /// Removes a package and its associated data from the database.
    pub async fn remove_package(&self, pkg_name: &str) -> Result<(), sqlx::Error> {
        info!("db.remove_package.removing", pkg_name);
        sqlx::query("DELETE FROM installed_files WHERE package_name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;
        sqlx::query("DELETE FROM dependencies WHERE package_name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;
        sqlx::query("DELETE FROM packages WHERE name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;
        info!("db.remove_package.removed", pkg_name);
        Ok(())
    }

    /// Returns the current version of a package, if installed.
    pub async fn get_package_version(&self, pkg_name: &str) -> Result<Option<String>, sqlx::Error> {
        debug!("db.get_package_version.fetching", pkg_name);
        let row = sqlx::query("SELECT version FROM packages WHERE name = ? AND current = 1")
            .bind(pkg_name)
            .fetch_optional(&self.pool)
            .await?;
        let result = row.map(|r| r.get::<String, _>("version"));
        debug!("db.get_package_version.result", pkg_name, &result);
        Ok(result)
    }

    pub async fn get_latest_package_version(
        &self,
        pkg_name: &str,
    ) -> Result<Option<Package>, sqlx::Error> {
        debug!("db.get_latest_package_version.fetching", pkg_name);

        // Get all packages with the given name
        let rows =
            sqlx::query("SELECT name, version, author, src, checksum FROM packages WHERE name = ?")
                .bind(pkg_name)
                .fetch_all(&self.pool)
                .await?;

        if rows.is_empty() {
            debug!("db.get_latest_package_version.not_found", pkg_name);
            return Ok(None);
        }

        // Parse packages and find the one with maximum version
        let mut packages = Vec::new();

        for row in rows {
            let version_str: String = row.get("version");
            if let Ok(version) = Version::parse(&version_str) {
                packages.push((row, version));
            } else {
                debug!(
                    "db.get_latest_package_version.invalid_version",
                    pkg_name, &version_str
                );
            }
        }

        if packages.is_empty() {
            debug!("db.get_latest_package_version.no_valid_versions", pkg_name);
            return Ok(None);
        }

        // Find the package with maximum version
        let (latest_row, latest_version) = packages
            .into_iter()
            .max_by(|(_, a), (_, b)| a.cmp(b))
            .expect("packages is not empty");

        debug!(
            "db.get_latest_package_version.found",
            pkg_name, &latest_version
        );

        let package = Package::new(
            latest_row.get::<String, _>("name"),
            latest_version,
            latest_row.get::<String, _>("author"),
            Source::Raw(latest_row.get::<String, _>("src")),
            latest_row.get::<String, _>("checksum"),
            Vec::new(), // Empty dependencies for now
        );

        debug!("db.get_latest_package_version.retrieved", &package);
        Ok(Some(package))
    }

    /// Lists all installed packages.
    pub async fn list_packages(&self) -> Result<Vec<(String, String, bool)>, sqlx::Error> {
        debug!("db.list_packages.listing");
        let rows = sqlx::query("SELECT name, version, current FROM packages")
            .fetch_all(&self.pool)
            .await?;

        let mut packages = Vec::new();
        for row in rows {
            let name: String = row.get("name");
            let version: String = row.get("version");
            let current: bool = row.get("current");
            debug!("db.list_packages.found", &name, &version, current);
            packages.push((name, version, current));
        }

        Ok(packages)
    }

    /// Checks if a package is installed and returns its latest version.
    pub async fn is_installed(&self, name: &str) -> Result<Option<Version>, sqlx::Error> {
        debug!("db.is_installed.checking", name);
        let row = sqlx::query(
            "SELECT version FROM packages WHERE name = ? ORDER BY version DESC LIMIT 1",
        )
        .bind(name)
        .fetch_optional(&self.pool)
        .await?;

        if let Some(r) = row {
            let ver_str: String = r.get("version");
            let ver = Version::parse(&ver_str).unwrap_or_else(|_| Version::new(0, 0, 0));
            debug!("db.is_installed.latest_version", name, &ver);
            Ok(Some(ver))
        } else {
            debug!("db.is_installed.not_found", name);
            Ok(None)
        }
    }

    /// Retrieves the current package metadata, including dependencies.
    pub async fn get_current_package(
        &self,
        pkg_name: &str,
    ) -> Result<Option<Package>, sqlx::Error> {
        debug!("db.get_current_package.fetching", pkg_name);
        let row = sqlx::query(
            "SELECT name, version, author, src, checksum FROM packages WHERE name = ? LIMIT 1",
        )
        .bind(pkg_name)
        .fetch_optional(&self.pool)
        .await?;

        let row = match row {
            Some(r) => r,
            None => {
                debug!("db.get_current_package.not_found", pkg_name);
                return Ok(None);
            }
        };

        // Dependencies
        let dep_rows = sqlx::query(
            "SELECT dependency_name, dependency_version FROM dependencies WHERE package_name = ?",
        )
        .bind(pkg_name)
        .fetch_all(&self.pool)
        .await?;

        let mut dependencies = Vec::new();
        for dep in dep_rows {
            let dep_name: String = dep.get("dependency_name");
            let dep_version_str: String = dep.get("dependency_version");
            if let Ok(dep_version) = Version::parse(&dep_version_str) {
                dependencies.push((dep_name, dep_version));
            }
        }

        let package = Package::new(
            row.get::<String, _>("name"),
            Version::parse(&row.get::<String, _>("version"))
                .unwrap_or_else(|_| Version::new(0, 0, 0)),
            row.get::<String, _>("author"),
            Source::Raw(row.get::<String, _>("src")),
            row.get::<String, _>("checksum"),
            dependencies,
        );

        debug!("db.get_current_package.retrieved", &package);
        Ok(Some(package))
    }

    /// Sets a specific version of a package as the current version.
    pub async fn set_current_version(
        &self,
        pkg_name: &str,
        version: &str,
    ) -> Result<(), sqlx::Error> {
        info!("db.set_current_version.setting", version, pkg_name);
        sqlx::query("UPDATE packages SET current = 0 WHERE name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;

        sqlx::query("UPDATE packages SET current = 1 WHERE name = ? AND version = ?")
            .bind(pkg_name)
            .bind(version)
            .execute(&self.pool)
            .await?;

        info!("db.set_current_version.success", version, pkg_name);
        Ok(())
    }

    /// Retrieves a specific version of a package by name and version string.
    pub async fn get_package_by_version(
        &self,
        pkg_name: &str,
        pkg_version: &str,
    ) -> Result<Option<Package>, sqlx::Error> {
        debug!("db.get_package_by_version.fetching", pkg_name, pkg_version);
        let row = sqlx::query(
            "SELECT name, version, author, src, checksum
             FROM packages
             WHERE name = ? AND version = ? LIMIT 1",
        )
        .bind(pkg_name)
        .bind(pkg_version)
        .fetch_optional(&self.pool)
        .await?;

        let row = match row {
            Some(r) => r,
            None => {
                debug!("db.get_package_by_version.not_found", pkg_name, pkg_version);
                return Ok(None);
            }
        };

        // Dependencies
        let dep_rows = sqlx::query(
            "SELECT dependency_name, dependency_version
             FROM dependencies
             WHERE package_name = ?",
        )
        .bind(pkg_name)
        .fetch_all(&self.pool)
        .await?;

        let mut dependencies = Vec::new();
        for dep in dep_rows {
            let dep_name: String = dep.get("dependency_name");
            let dep_version_str: String = dep.get("dependency_version");
            if let Ok(dep_version) = Version::parse(&dep_version_str) {
                dependencies.push((dep_name, dep_version));
            }
        }

        let package = Package::new(
            row.get::<String, _>("name"),
            Version::parse(&row.get::<String, _>("version"))
                .unwrap_or_else(|_| Version::new(0, 0, 0)),
            row.get::<String, _>("author"),
            Source::Raw(row.get::<String, _>("src")),
            row.get::<String, _>("checksum"),
            dependencies,
        );

        debug!("db.get_package_by_version.retrieved", &package);
        Ok(Some(package))
    }
}
############### ENDOFFILE ########################

############### error.rs #########################
use ron::error::SpannedError;
use semver::Version;
use std::path::PathBuf;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum SwitchError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("Package directory not found: {0}")]
    MissingPackageDir(PathBuf),
    #[error("Symlist error: {0}")]
    Symlist(#[from] crate::symlist::SymlistError),
    #[error("Package not found: {0} version {1}")]
    PackageNotFound(String, Version),
}

#[derive(Error, Debug)]
pub enum UpdaterError {
    #[error("Package not found: {0}")]
    NotFound(String),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Repository error: {0}")]
    Repo(#[from] RepoError),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("Fetch error: {0}")]
    Fetch(#[from] FetchError),
    #[error("No newer version available for package: {0}")]
    NoNewVersion(String),
}

#[derive(Error, Debug)]
pub enum UhpmError {
    #[error("Configuration error: {0}")]
    Config(#[from] ConfigError),
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    #[error("Repository error: {0}")]
    Repository(#[from] RepoError),
    #[error("Package error: {0}")]
    Package(String),
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Parse error: {0}")]
    Parse(String),
    #[error("Package not found: {0}")]
    NotFound(String),
    #[error("No newer version available for package: {0}")]
    NoNewVersion(String),
    #[error("Validation error: {0}")]
    Validation(String),
}

#[derive(Error, Debug)]
pub enum RemoveError {
    #[error("Package not found: {0}")]
    NotFound(String),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("RON parse error: {0}")]
    Ron(#[from] SpannedError),
    #[error("Configuration file not found: {0}")]
    NotFound(String),
}

#[derive(Error, Debug)]
pub enum RepoError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("Package not found: {0}")]
    NotFound(String),
}

#[derive(Error, Debug)]
pub enum FetchError {
    #[error("HTTP error: {0}")]
    Http(#[from] reqwest::Error),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Installer error: {0}")]
    Installer(String),
}

#[derive(Error, Debug)]
pub enum MetaParseError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("RON parse error: {0}")]
    Ron(#[from] SpannedError),
}

impl From<SwitchError> for UhpmError {
    fn from(error: SwitchError) -> Self {
        match error {
            SwitchError::Io(e) => UhpmError::Io(e),
            SwitchError::Db(e) => UhpmError::Database(e),
            SwitchError::MissingPackageDir(path) => {
                UhpmError::NotFound(format!("Package directory not found: {}", path.display()))
            }
            SwitchError::Symlist(e) => UhpmError::Parse(e.to_string()),
            SwitchError::PackageNotFound(name, version) => {
                UhpmError::NotFound(format!("Package {} version {} not found", name, version))
            }
        }
    }
}

impl From<UpdaterError> for UhpmError {
    fn from(error: UpdaterError) -> Self {
        match error {
            UpdaterError::NotFound(name) => UhpmError::NotFound(name),
            UpdaterError::Io(e) => UhpmError::Io(e),
            UpdaterError::Repo(e) => UhpmError::Repository(e),
            UpdaterError::Db(e) => UhpmError::Database(e),
            UpdaterError::Fetch(e) => UhpmError::from(e),
            UpdaterError::NoNewVersion(name) => UhpmError::NoNewVersion(name),
        }
    }
}

impl From<FetchError> for UhpmError {
    fn from(error: FetchError) -> Self {
        match error {
            FetchError::Http(e) => UhpmError::Network(e),
            FetchError::Io(e) => UhpmError::Io(e),
            FetchError::Installer(msg) => UhpmError::Package(msg),
        }
    }
}

impl From<MetaParseError> for UhpmError {
    fn from(error: MetaParseError) -> Self {
        match error {
            MetaParseError::Io(e) => UhpmError::Io(e),
            MetaParseError::Ron(e) => UhpmError::Parse(e.to_string()),
        }
    }
}

impl From<RemoveError> for UhpmError {
    fn from(error: RemoveError) -> Self {
        match error {
            RemoveError::NotFound(name) => UhpmError::NotFound(name),
            RemoveError::Db(e) => UhpmError::Database(e),
            RemoveError::Io(e) => UhpmError::Io(e),
        }
    }
}

impl From<String> for UhpmError {
    fn from(error: String) -> Self {
        UhpmError::Package(error)
    }
}

impl From<&str> for ConfigError {
    fn from(s: &str) -> Self {
        ConfigError::NotFound(s.to_string())
    }
}
############### ENDOFFILE ########################

############### fetcher.rs #########################
//! # Package Fetcher
//!
//! This module handles downloading packages from URLs (HTTP or local `file://` paths)
//! and installing them into UHPM.
//!
//! ## Responsibilities
//! - Download `.uhp` package archives from repositories or local paths.
//! - Provide progress bars for concurrent downloads.
//! - Integrate with the [`installer`](crate::package::installer) to complete installation.
//!
//! ## Features
//! - Supports both **HTTP(S)** and **file://** sources.
//! - Parallel downloading using [`FuturesUnordered`].
//! - Progress display via [`indicatif`].
//! - Error handling through [`FetchError`].
//!
//! ## Example
//! ```rust,no_run
//! use uhpm::db::PackageDB;
//! use uhpm::fetcher::fetch_and_install_parallel;
//! # use std::path::Path;
//!
//! # tokio_test::block_on(async {
//! let db = PackageDB::new(Path::new("/tmp/uhpm.db"))
//!     .unwrap()
//!     .init()
//!     .await
//!     .unwrap();
//!
//! let urls = vec![
//!     "https://example.com/package.uhp".to_string(),
//!     "file:///home/user/package.uhp".to_string()
//! ];
//!
//! fetch_and_install_parallel(&urls, &db).await.unwrap();
//! # });
//! ```

use crate::db::PackageDB;
use crate::error::FetchError;
use crate::package::installer;
use crate::{error, info};
use futures::stream::{FuturesUnordered, StreamExt};
use indicatif::{ProgressBar, ProgressStyle};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use tokio::fs;

/// Errors that can occur during package fetching and installation.

/// Downloads a single package from the given URL.
///
/// - Supports both `http(s)://` and `file://` schemes.
/// - For local `file://` paths, simply converts to [`PathBuf`].
/// - For remote URLs, saves the response to the temporary directory.
///
/// # Errors
/// Returns a [`FetchError`] if the request or file writing fails.
async fn download_package(url: &str) -> Result<PathBuf, FetchError> {
    if let Some(stripped) = url.strip_prefix("file://") {
        Ok(PathBuf::from(stripped))
    } else {
        let resp = reqwest::get(url).await?.bytes().await?;
        let tmp_dir = std::env::temp_dir();
        let filename = Path::new(url)
            .file_name()
            .and_then(|f| f.to_str())
            .ok_or_else(|| {
                FetchError::Io(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    "Unable to determine filename from URL",
                ))
            })?;
        let tmp_path = tmp_dir.join(filename);
        fs::write(&tmp_path, &resp).await?;
        Ok(tmp_path)
    }
}

/// Downloads multiple packages concurrently.
///
/// Shows a progress bar using [`indicatif`] while downloading.
/// Returns a map of successfully downloaded URLs to local file paths.
pub async fn fetch_packages(urls: &[String]) -> HashMap<String, PathBuf> {
    let bar = ProgressBar::new(urls.len() as u64);
    bar.set_style(
        ProgressStyle::default_bar()
            .template("[{bar:40.cyan/blue}] {pos}/{len} {msg}")
            .unwrap()
            .progress_chars("##-"),
    );

    let mut futures = FuturesUnordered::new();
    for url in urls {
        let url_clone = url.clone();
        futures.push(async move {
            let path = download_package(&url_clone).await;
            (url_clone, path)
        });
    }

    let mut results = HashMap::new();
    while let Some((url, res)) = futures.next().await {
        match res {
            Ok(path) => {
                results.insert(url.clone(), path);
                bar.inc(1);
                bar.set_message(format!("Downloaded: {}", url));
            }
            Err(e) => {
                error!("fetcher.download.failed", url, e);
                bar.inc(1);
            }
        }
    }
    bar.finish_with_message("Download complete");
    results
}

/// Installs already downloaded packages into the database.
///
/// # Errors
/// Returns [`FetchError::Installer] if the installation fails.
pub async fn install_fetched_packages(
    packages: &HashMap<String, PathBuf>,
    package_db: &PackageDB,
) -> Result<(), FetchError> {
    for (url, path) in packages {
        info!("fetcher.install.from_url", url);
        installer::install(path, package_db).await.map_err(|e| {
            FetchError::Installer(format!("Installation failed for {}: {:?}", url, e))
        })?;
    }
    Ok(())
}

/// Downloads and installs packages in parallel.
///
/// - Downloads all URLs concurrently.
/// - Installs them sequentially after downloading.
///
/// # Errors
/// Returns [`FetchError`] if downloading or installation fails.
pub async fn fetch_and_install_parallel(
    urls: &[String],
    package_db: &PackageDB,
) -> Result<(), FetchError> {
    let downloaded = fetch_packages(urls).await;
    install_fetched_packages(&downloaded, package_db).await?;
    Ok(())
}
############### ENDOFFILE ########################

############### lib.rs #########################
pub mod cli;
pub mod config;
pub mod db;
pub mod error;
pub mod fetcher;
pub mod locale;
pub mod log;
pub mod package;
pub mod repo;
pub mod service;
pub mod symlist;

use std::fs;

pub fn clear_tmp() -> std::io::Result<()> {
    let mut tmp_dir = dirs::home_dir().unwrap();
    tmp_dir.push(".uhpm/tmp");

    if tmp_dir.exists() {
        fs::remove_dir_all(&tmp_dir)?;
        fs::create_dir_all(&tmp_dir)?;
    }

    Ok(())
}
############### ENDOFFILE ########################

############### locale.rs #########################
//! locale.rs
//!
//! Provides localization support for UHPM.
//! Features:
//! - Automatic detection of system locale
//! - Loading translations from `locale/<lang>.ron`
//! - Retrieving localized messages

use std::{collections::HashMap, fs, path::Path};
use sys_locale::get_locale;
use tracing::warn;

/// Main struct for localization
#[derive(Debug)]
pub struct Locale {
    /// Active language code, e.g., "en", "ru"
    pub lang: String,
    /// Loaded localized messages
    pub messages: HashMap<String, String>,
}

impl Locale {
    /// Initializes a Locale instance
    /// - Detects system locale
    /// - Loads the corresponding translation file from `locale/<lang>.ron`
    pub fn initialize() -> Self {
        let lang_full = get_locale().unwrap_or_else(|| "en".to_string());
        let lang = lang_full.chars().take(2).collect::<String>();
        let messages = Self::load_messages(&lang).unwrap_or_else(|err| {
            warn!("Failed to load locale '{}': {}", lang, err);
            HashMap::new()
        });

        Self { lang, messages }
    }

    /// Loads messages from RON file and flattens the structure
    fn load_messages(lang: &str) -> Result<HashMap<String, String>, Box<dyn std::error::Error>> {
        #[cfg(debug_assertions)]
        let path = Path::new("locale").join(format!("{}.ron", lang));

        #[cfg(not(debug_assertions))]
        let path = dirs::home_dir()
            .unwrap()
            .join(".uhpm")
            .join("locale")
            .join(format!("{}.ron", lang));

        if !path.exists() {
            return Err(format!("Locale file not found: {:?}", path).into());
        }

        let content = fs::read_to_string(&path)?;

        // Parse RON into Value
        let value: ron::Value = ron::from_str(&content)?;

        // Recursively collect all strings into a flat HashMap
        let mut messages = HashMap::new();
        Self::flatten_value(value, &mut messages, String::new());

        Ok(messages)
    }

    /// Recursively traverses RON structure and collects all strings
    fn flatten_value(
        value: ron::Value,
        messages: &mut HashMap<String, String>,
        current_key: String,
    ) {
        match value {
            ron::Value::Map(map) => {
                for (key, value) in map.into_iter() {
                    // Only string keys are processed
                    if let ron::Value::String(key_str) = key {
                        let new_key = if current_key.is_empty() {
                            key_str
                        } else {
                            format!("{}.{}", current_key, key_str)
                        };
                        Self::flatten_value(value, messages, new_key);
                    }
                    // Other key types are ignored
                }
            }
            ron::Value::String(s) => {
                messages.insert(current_key, s);
            }
            _ => {} // Ignore numbers, booleans, etc. - only strings matter
        }
    }

    /// Retrieves a localized message by key
    /// Falls back to the key itself if translation is missing
    pub fn msg(&self, key: &str) -> String {
        self.messages
            .get(key)
            .cloned()
            .unwrap_or_else(|| key.to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_subscriber;

    #[test]
    fn test_locale_load() {
        tracing_subscriber::fmt::init();

        let locale = Locale::initialize();
        println!("Active locale: {}", locale.lang);

        let msg = locale.msg("main.info.uhpm_started");
        println!("Localized message: {}", msg);

        assert!(locale.lang.len() == 2 || locale.lang.len() == 1);
    }
}
############### ENDOFFILE ########################

############### log.rs #########################
//! log.rs
//!
//! Localized logging with auto-detected system locale.
//! Provides macros: info!(), warn!(), debug!(), error!(), lprintln!(), lprint!().
//! Supports multiple arguments of any type and substitutes them in order.

use crate::locale::Locale;
use once_cell::sync::Lazy;

/// Global static logger
pub static LOGGER: Lazy<Locale> = Lazy::new(|| Locale::initialize());

/// Helper: replaces `{}` placeholders in template with provided arguments
pub fn format_ordered(template: &str, args: &[String]) -> String {
    let mut result = String::new();
    let mut parts = template.split("{}");
    let mut iter = args.iter();

    if let Some(first) = parts.next() {
        result.push_str(first);
    }

    for part in parts {
        if let Some(arg) = iter.next() {
            result.push_str(arg);
        }
        result.push_str(part);
    }

    result
}

/// Internal helper to format any type with Debug
pub fn fmt_debug<T: std::fmt::Debug>(val: T) -> String {
    format!("{:?}", val)
}

// -------------------- MACROS -------------------- //

#[macro_export]
macro_rules! info {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::info!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! warn {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::warn!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! debug {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::debug!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! error {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::error!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! lprintln {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            println!("{}", msg);
        }
    };
}

#[macro_export]
macro_rules! lprint {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            print!("{}", msg);
        }
    };
}
############### ENDOFFILE ########################

############### package.rs #########################
//! # Package Module

use crate::error::MetaParseError;
use semver::Version;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
pub mod installer;
pub mod remover;
pub mod switcher;
pub mod updater;

/// Represents the source of a package.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", content = "value")]
pub enum Source {
    Url(String),
    LocalPath(String),
    Raw(String),
}

impl Source {
    pub fn as_str(&self) -> &str {
        match self {
            Source::Url(s) | Source::Raw(s) => s,
            Source::LocalPath(p) => p,
        }
    }
}

/// Represents a dependency with name and version
#[derive(Serialize, Deserialize, Debug)]
pub struct Dependency {
    pub name: String,
    pub version: Version,
}

/// Represents a UHPM package with its metadata and dependencies.
#[derive(Serialize, Deserialize, Debug)]
pub struct Package {
    name: String,
    author: String,
    version: Version,
    src: Source,
    checksum: String,
    #[serde(default)]
    dependencies: Vec<Dependency>,
}

impl Package {
    pub fn new(
        name: impl Into<String>,
        version: Version,
        author: impl Into<String>,
        src: Source,
        checksum: impl Into<String>,
        dependencies: Vec<(String, Version)>,
    ) -> Self {
        let deps = dependencies
            .into_iter()
            .map(|(name, version)| Dependency { name, version })
            .collect();

        Self {
            name: name.into(),
            version,
            author: author.into(),
            src,
            checksum: checksum.into(),
            dependencies: deps,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn author(&self) -> &str {
        &self.author
    }

    pub fn version(&self) -> &Version {
        &self.version
    }

    pub fn src(&self) -> &Source {
        &self.src
    }

    pub fn checksum(&self) -> &str {
        &self.checksum
    }

    pub fn dependencies(&self) -> Vec<(String, Version)> {
        self.dependencies
            .iter()
            .map(|dep| (dep.name.clone(), dep.version.clone()))
            .collect()
    }

    pub fn from_toml_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let data = fs::read_to_string(path)?;
        let pkg: Package = toml::from_str(&data)?;
        Ok(pkg)
    }

    pub fn template() -> Self {
        Package {
            name: "my_package".to_string(),
            author: "YourName".to_string(),
            version: Version::parse("0.1.0").unwrap(),
            src: Source::Raw("TODO".to_string()),
            checksum: "TODO".to_string(),
            dependencies: vec![],
        }
    }

    pub fn save_to_toml(&self, path: &std::path::Path) -> Result<(), Box<dyn std::error::Error>> {
        let toml_str = toml::to_string_pretty(self)?;
        std::fs::write(path, toml_str)?;
        Ok(())
    }
}

pub fn meta_parser(meta_path: &Path) -> Result<Package, MetaParseError> {
    let data = fs::read_to_string(meta_path)?;
    let pkg: Package = toml::from_str(&data).map_err(|e| {
        MetaParseError::Io(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("TOML parse error: {}", e),
        ))
    })?;
    Ok(pkg)
}

pub fn get_pkg_path(pkg_name: &str, pkg_ver: Version) -> PathBuf {
    let packages_path: PathBuf = dirs::home_dir().unwrap().join(".uhpm").join("packages");
    packages_path.join(format!("{}-{}", pkg_name, pkg_ver.to_string()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use semver::Version;
    use std::fs;

    fn sample_package_toml() -> String {
        r#"
name = "test_pkg"
author = "Tester"
version = "0.1.0"
checksum = "abc123"

[src]
type = "Raw"
value = "some content"

[[dependencies]]
name = "dep_pkg"
version = "1.0.0"
"#
        .to_string()
    }

    #[test]
    fn test_from_toml_file() {
        let tmp_dir = tempfile::tempdir().unwrap();
        let toml_path = tmp_dir.path().join("uhp.toml");
        fs::write(&toml_path, sample_package_toml()).unwrap();

        let pkg = Package::from_toml_file(&toml_path).unwrap();
        assert_eq!(pkg.name(), "test_pkg");
        assert_eq!(pkg.author(), "Tester");
        assert_eq!(pkg.version(), &Version::parse("0.1.0").unwrap());
        assert_eq!(pkg.src().as_str(), "some content");
        assert_eq!(pkg.checksum(), "abc123");
        assert_eq!(pkg.dependencies().len(), 1);
        assert_eq!(pkg.dependencies()[0].0, "dep_pkg");
        assert_eq!(pkg.dependencies()[0].1, Version::parse("1.0.0").unwrap());
    }

    #[test]
    fn test_meta_parser() {
        let tmp_dir = tempfile::tempdir().unwrap();
        let toml_path = tmp_dir.path().join("uhp.toml");
        fs::write(&toml_path, sample_package_toml()).unwrap();

        let pkg = meta_parser(&toml_path).unwrap();
        assert_eq!(pkg.name(), "test_pkg");
        assert_eq!(pkg.author(), "Tester");
    }

    #[test]
    fn test_save_and_load_toml() {
        let tmp_dir = tempfile::tempdir().unwrap();
        let toml_path = tmp_dir.path().join("test_pkg.toml");

        let original_pkg = Package::new(
            "test_package",
            Version::parse("1.2.3").unwrap(),
            "Test Author",
            Source::Url("https://example.com/pkg.uhp".to_string()),
            "sha256:abc123",
            vec![
                ("dep1".to_string(), Version::parse("1.0.0").unwrap()),
                ("dep2".to_string(), Version::parse("2.0.0").unwrap()),
            ],
        );

        original_pkg.save_to_toml(&toml_path).unwrap();

        // Проверим, что сохранилось правильно
        let saved_content = fs::read_to_string(&toml_path).unwrap();
        println!("Saved TOML:\n{}", saved_content);

        let loaded_pkg = Package::from_toml_file(&toml_path).unwrap();

        assert_eq!(original_pkg.name(), loaded_pkg.name());
        assert_eq!(original_pkg.author(), loaded_pkg.author());
        assert_eq!(original_pkg.version(), loaded_pkg.version());
        assert_eq!(original_pkg.checksum(), loaded_pkg.checksum());
        assert_eq!(
            original_pkg.dependencies().len(),
            loaded_pkg.dependencies().len()
        );
    }

    #[test]
    fn test_source_serialization() {
        let pkg = Package::new(
            "test",
            Version::parse("1.0.0").unwrap(),
            "author",
            Source::Raw("content".to_string()),
            "checksum",
            vec![],
        );

        let toml_str = toml::to_string_pretty(&pkg).unwrap();
        println!("Serialized package:\n{}", toml_str);

        // Проверим, что можем десериализовать обратно
        let deserialized: Package = toml::from_str(&toml_str).unwrap();
        assert_eq!(pkg.name(), deserialized.name());
    }
}
############### ENDOFFILE ########################

############### repo.rs #########################
//! # Repository Module
//!
//! This module defines [`RepoDB`] and related utilities for managing package
//! repositories in **UHPM (Universal Home Package Manager)**.
//!
//! ## Responsibilities
//! - Store metadata about available packages in a repository (SQLite).
//! - Provide URLs for downloading package archives.
//! - Parse repository configuration files (`repos.ron`).
//!
//! ## Tables
//! - **`packages`**
//!   - Stores basic package metadata: `name`, `version`, `author`, `src`, `checksum`.
//! - **`urls`**
//!   - Maps `(name, version)` pairs to download URLs.
//!
//! ## Example
//! ```rust,no_run
//! use uhpm::repo::RepoDB;
//! use std::path::Path;
//!
//! # tokio_test::block_on(async {
//! let repo_db = RepoDB::new(Path::new("/tmp/repo.db")).await.unwrap();
//!
//! // Add a package
//! repo_db.add_package("foo", "1.0.0", "Alice", "src", "sha256").await.unwrap();
//! repo_db.add_url("foo", "1.0.0", "https://example.com/foo-1.0.0.uhp").await.unwrap();
//!
//! // List packages
//! let pkgs = repo_db.list_packages().await.unwrap();
//! println!("{:?}", pkgs);
//! # });
//! ```

use crate::error::RepoError;
use ron::from_str;
use sqlx::{Row, SqlitePool};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Errors that may occur while working with repositories.

/// SQLite-backed package repository database.
///
/// Used for storing available package metadata and their download URLs.
pub struct RepoDB {
    pool: SqlitePool,
}

impl RepoDB {
    pub fn pool(&self) -> &SqlitePool {
        return &self.pool;
    }
    /// Opens (or creates) a new repository database at the given path.
    ///
    /// Ensures required tables exist by calling [`RepoDB::init_tables`].
    pub async fn new(db_path: &Path) -> Result<Self, sqlx::Error> {
        if !db_path.exists() {
            if let Some(parent) = db_path.parent() {
                std::fs::create_dir_all(parent).expect("Failed to create directory for database");
            }
            std::fs::File::create(db_path).expect("Cannot create database file");
        }

        let db_url = format!("sqlite://{}", db_path.to_str().unwrap());
        let pool = SqlitePool::connect(&db_url).await?;
        let db = RepoDB { pool };
        db.init_tables().await?;
        Ok(db)
    }

    /// Initializes required tables (`packages`, `urls`) if they don’t exist.
    async fn init_tables(&self) -> Result<(), sqlx::Error> {
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS packages (
                name TEXT NOT NULL,
                version TEXT NOT NULL,
                author TEXT NOT NULL,
                src TEXT NOT NULL,
                checksum TEXT NOT NULL,
                PRIMARY KEY(name, version)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS urls (
                name TEXT NOT NULL,
                version TEXT NOT NULL,
                url TEXT NOT NULL,
                PRIMARY KEY(name, version)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    /// Returns the download URL for a given package name and version.
    ///
    /// # Errors
    /// Returns [`RepoError::NotFound`] if no URL is found.
    pub async fn get_package(&self, name: &str, version: &str) -> Result<String, RepoError> {
        let row = sqlx::query("SELECT url FROM urls WHERE name = ? AND version = ?")
            .bind(name)
            .bind(version)
            .fetch_optional(&self.pool)
            .await?;

        match row {
            Some(r) => Ok(r.get::<String, _>("url")),
            None => Err(RepoError::NotFound(format!("{}-{}", name, version))),
        }
    }

    /// Lists all packages (name and version) available in this repository.
    pub async fn list_packages(&self) -> Result<Vec<(String, String)>, sqlx::Error> {
        let rows = sqlx::query("SELECT name, version FROM packages")
            .fetch_all(&self.pool)
            .await?;

        let packages = rows
            .into_iter()
            .map(|r| (r.get::<String, _>("name"), r.get::<String, _>("version")))
            .collect();

        Ok(packages)
    }

    /// Adds a package record to the repository (metadata only).
    pub async fn add_package(
        &self,
        name: &str,
        version: &str,
        author: &str,
        src: &str,
        checksum: &str,
    ) -> Result<(), sqlx::Error> {
        sqlx::query(
            "INSERT OR IGNORE INTO packages (name, version, author, src, checksum) VALUES (?, ?, ?, ?, ?)"
        )
        .bind(name)
        .bind(version)
        .bind(author)
        .bind(src)
        .bind(checksum)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    /// Adds or replaces a download URL for a package version.
    pub async fn add_url(&self, name: &str, version: &str, url: &str) -> Result<(), sqlx::Error> {
        sqlx::query("INSERT OR REPLACE INTO urls (name, version, url) VALUES (?, ?, ?)")
            .bind(name)
            .bind(version)
            .bind(url)
            .execute(&self.pool)
            .await?;
        Ok(())
    }
}

/// Parses a `.ron` repositories configuration file.
///
/// The file should define a map of repository names to paths/URLs.
/// Example (`repos.ron`):
/// ```ron
/// {
///     "local": "file:///home/user/uhpm-repo",
///     "main": "https://example.com/uhpm-repo"
/// }
/// ```
pub fn parse_repos<P: AsRef<Path>>(path: P) -> Result<HashMap<String, String>, RepoError> {
    let content = fs::read_to_string(path)?;
    let repos: HashMap<String, String> = from_str(&content).unwrap();
    Ok(repos)
}
############### ENDOFFILE ########################

############### symlist.rs #########################
//! # Symlist
//!
//! This module handles **symbolic link lists** (`symlist`),
//! which describe what files from an installed package should be symlinked
//! into user/system paths.
//!
//! ## Example format (`symlist`)
//! ```text
//! /path/to/package/bin/my_binary $HOME/.local/bin/my_binary
//! /path/to/package/share/applications/app.desktop $XDG_DATA_HOME/applications/app.desktop
//! ```
//!
//! ## Supported variables
//! - `$HOME` — user home directory
//! - `$XDG_DATA_HOME` — user data directory (defaults to `~/.local/share`)
//! - `$XDG_CONFIG_HOME` — user config directory (defaults to `~/.config`)
//! - `$XDG_BIN_HOME` — user bin directory (defaults to `~/.local/bin`)
//!
//! These variables are automatically expanded in target paths.

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use thiserror::Error;

/// Possible errors when working with symlists
#[derive(Debug, Error)]
pub enum SymlistError {
    /// Input/output error
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    /// Symlist parsing error
    #[error("Symlist parse error: {0}")]
    Parse(String),
}

/// Entry in the symlink list
#[derive(Debug)]
pub struct SymlinkEntry {
    /// Relative path inside the package
    pub source: String,
    /// Target path (with variables)
    pub target: String,
}

/// Expands variables (`$HOME`, `$XDG_*`) in paths
fn expand_vars(path: &str) -> PathBuf {
    let mut vars = HashMap::new();

    if let Some(home) = dirs::home_dir() {
        let home_str = home.to_string_lossy().to_string();

        vars.insert("HOME".to_string(), home_str.clone());

        vars.insert(
            "XDG_DATA_HOME".to_string(),
            std::env::var("XDG_DATA_HOME").unwrap_or_else(|_| format!("{}/.local/share", home_str)),
        );
        vars.insert(
            "XDG_CONFIG_HOME".to_string(),
            std::env::var("XDG_CONFIG_HOME").unwrap_or_else(|_| format!("{}/.config", home_str)),
        );
        vars.insert(
            "XDG_BIN_HOME".to_string(),
            std::env::var("XDG_BIN_HOME").unwrap_or_else(|_| format!("{}/.local/bin", home_str)),
        );
    }

    let mut expanded = path.to_string();
    for (key, value) in vars {
        expanded = expanded.replace(&format!("${}", key), &value);
    }

    PathBuf::from(expanded)
}

/// Parses a single line from symlist file
fn parse_symlist_line(line: &str) -> Result<SymlinkEntry, SymlistError> {
    let line = line.trim();

    // Skip empty lines and comments
    if line.is_empty() || line.starts_with('#') {
        return Err(SymlistError::Parse("Empty or comment line".to_string()));
    }

    let parts: Vec<&str> = line.splitn(2, ' ').collect();
    if parts.len() != 2 {
        return Err(SymlistError::Parse(format!(
            "Invalid line format, expected 'source target', got: {}",
            line
        )));
    }

    let source = parts[0].trim().to_string();
    let target = parts[1].trim().to_string();

    if source.is_empty() || target.is_empty() {
        return Err(SymlistError::Parse(
            "Source or target cannot be empty".to_string(),
        ));
    }

    Ok(SymlinkEntry { source, target })
}

/// Saves a symlist template (`symlist`)
///
/// Useful for package initialization or project bootstrapping.
///
/// # Example
/// ```no_run
/// use uhpm::symlist::save_template;
/// use std::path::Path;
///
/// save_template(Path::new("symlist")).unwrap();
/// ```
pub fn save_template(path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let symlist_template = r#"# Symlink list for package
# Format: <source_path> <target_path_with_variables>
#
# Available variables:
#   $HOME - user home directory
#   $XDG_DATA_HOME - user data directory (~/.local/share)
#   $XDG_CONFIG_HOME - user config directory (~/.config)
#   $XDG_BIN_HOME - user bin directory (~/.local/bin)

bin/my_binary $HOME/.local/bin/my_binary
share/applications/my_app.desktop $XDG_DATA_HOME/applications/my_app.desktop
"#;
    fs::write(path, symlist_template)?;
    Ok(())
}

/// Loads a symlink list from `symlist` file
///
/// - `path` — path to the symlist file
/// - `package_root` — root directory of the package
///
/// Returns a vector of `(source_path, target_path)`.
///
/// # Errors
/// - [`SymlistError::Io`] — if the file cannot be read
/// - [`SymlistError::Parse`] — if the file has an invalid format
///
/// # Example
/// ```no_run
/// use uhpm::symlist::load_symlist;
/// use std::path::Path;
///
/// let symlinks = load_symlist(Path::new("symlist"), Path::new("/tmp/pkg_root")).unwrap();
/// for (src, dst) in symlinks {
///     println!("{} -> {}", src.display(), dst.display());
/// }
/// ```
pub fn load_symlist(
    path: &Path,
    package_root: &Path,
) -> Result<Vec<(PathBuf, PathBuf)>, SymlistError> {
    let content = fs::read_to_string(path)?;

    let mut entries = Vec::new();

    for (line_num, line) in content.lines().enumerate() {
        match parse_symlist_line(line) {
            Ok(entry) => entries.push(entry),
            Err(SymlistError::Parse(msg)) if msg.contains("Empty or comment") => {
                // Skip empty lines and comments
                continue;
            }
            Err(e) => {
                return Err(SymlistError::Parse(format!("Line {}: {}", line_num + 1, e)));
            }
        }
    }

    Ok(entries
        .into_iter()
        .map(|e| {
            let src = package_root.join(e.source);
            let dst = expand_vars(&e.target);
            (src, dst)
        })
        .collect())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::path::PathBuf;
    use tempfile::tempdir;

    #[test]
    fn test_expand_vars_home() {
        let home = dirs::home_dir().unwrap();
        let path = "$HOME/test_folder";
        let expanded = expand_vars(path);
        assert_eq!(expanded, home.join("test_folder"));
    }

    #[test]
    fn test_expand_vars_xdg() {
        let home = dirs::home_dir().unwrap();
        let xdg_data = std::env::var("XDG_DATA_HOME")
            .unwrap_or_else(|_| format!("{}/.local/share", home.to_string_lossy()));
        let path = "$XDG_DATA_HOME/some_dir";
        let expanded = expand_vars(path);
        assert_eq!(expanded, PathBuf::from(xdg_data).join("some_dir"));
    }

    #[test]
    fn test_parse_symlist_line() {
        let line = "/package/bin/foo $HOME/.local/bin/foo";
        let entry = parse_symlist_line(line).unwrap();
        assert_eq!(entry.source, "/package/bin/foo");
        assert_eq!(entry.target, "$HOME/.local/bin/foo");

        // Test with multiple spaces
        let line = "/package/bin/foo    $HOME/.local/bin/foo";
        let entry = parse_symlist_line(line).unwrap();
        assert_eq!(entry.source, "/package/bin/foo");
        assert_eq!(entry.target, "$HOME/.local/bin/foo");
    }

    #[test]
    fn test_parse_symlist_line_invalid() {
        // Missing target
        let line = "/package/bin/foo";
        assert!(parse_symlist_line(line).is_err());

        // Empty line
        let line = "";
        assert!(parse_symlist_line(line).is_err());

        // Comment line
        let line = "# This is a comment";
        assert!(parse_symlist_line(line).is_err());
    }

    #[test]
    fn test_load_symlist_parsing() {
        let tmp_dir = tempdir().unwrap();
        let symlist_path = tmp_dir.path().join("symlist");

        let content = r#"# This is a comment line

bin/foo $HOME/.local/bin/foo
config/bar $XDG_CONFIG_HOME/bar

# Another comment
share/data $XDG_DATA_HOME/app_data
"#;
        fs::write(&symlist_path, content).unwrap();

        let package_root = tmp_dir.path();
        let symlinks = load_symlist(&symlist_path, package_root).unwrap();

        assert_eq!(symlinks.len(), 3);

        assert_eq!(symlinks[0].0, package_root.join("bin/foo"));
        assert_eq!(symlinks[1].0, package_root.join("config/bar"));
        assert_eq!(symlinks[2].0, package_root.join("share/data"));

        assert!(symlinks[0].1.to_string_lossy().ends_with(".local/bin/foo"));
        assert!(symlinks[1].1.to_string_lossy().ends_with("bar"));
        assert!(symlinks[2].1.to_string_lossy().ends_with("app_data"));
    }
}
############### ENDOFFILE ########################

############### cli.rs #########################
use crate::service::PackageService;
use crate::{error, info, lprintln};
use clap::CommandFactory;
use clap::{Parser, Subcommand};
use clap_complete::{
    generate,
    shells::{Bash, Fish, Zsh},
};
use std::io;
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "uhpm", version, about = "Universal Home Package Manager")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    Install {
        #[arg(short, long)]
        file: Option<PathBuf>,
        #[arg(value_name = "PACKAGE")]
        package: Vec<String>,
        #[arg(short, long)]
        version: Option<String>,
    },
    Remove {
        #[arg(value_name = "PACKAGE")]
        packages: Vec<String>,
    },
    List,
    Update {
        #[arg(short, long)]
        file: Option<PathBuf>,
        #[arg(value_name = "PACKAGE")]
        packages: Vec<String>,
    },
    Switch {
        #[arg(value_name = "PACKAGE@VERSION")]
        target: String,
    },
    Completions {
        shell: String,
    },
}

impl Cli {
    pub async fn run(&self, service: &PackageService) -> Result<(), Box<dyn std::error::Error>> {
        match &self.command {
            Commands::Install {
                file,
                package,
                version,
            } => {
                if let Some(path) = file {
                    info!("cli.install.from_file", path.display());
                    service.install_from_file(path).await?;
                } else if !package.is_empty() {
                    for pkg_name in package {
                        info!("cli.install.from_repo", pkg_name);
                        service
                            .install_from_repo(pkg_name, version.as_deref())
                            .await?;
                    }
                } else {
                    error!("cli.install.no_file_or_package");
                }
            }

            Commands::Remove { packages } => {
                if packages.is_empty() {
                    error!("cli.remove.no_packages");
                } else {
                    for pkg_name in packages {
                        if pkg_name.contains('@') {
                            let parts: Vec<&str> = pkg_name.split('@').collect();
                            if parts.len() == 2 {
                                let (pkg_name, pkg_version) = (parts[0], parts[1]);
                                info!("cli.remove.parts", pkg_name, pkg_version);
                                service
                                    .remove_package_version(pkg_name, pkg_version)
                                    .await?;
                            } else {
                                error!("cli.remove.invalid_format", pkg_name);
                            }
                        } else {
                            info!("cli.remove.removing", pkg_name);
                            service.remove_package(pkg_name).await?;
                        }
                    }
                }
            }

            Commands::List => {
                let packages = service.list_packages().await?;
                if packages.is_empty() {
                    lprintln!("cli.list.no_packages");
                } else {
                    lprintln!("cli.list.installed_packages");
                    for (name, version, current) in packages {
                        let marker = if current { '*' } else { ' ' };
                        lprintln!("cli.list.package_format", name, version, marker);
                    }
                }
            }

            Commands::Update { file, packages } => {
                if let Some(path) = file {
                    info!("cli.update.from_file", path.display());
                    service.install_from_file(path).await?;
                } else {
                    for package in packages {
                        match service.update_package(package).await {
                            Ok(()) => info!("cli.update.success", package),
                            Err(e) => error!("cli.update.error", package, e),
                        }
                    }
                }
            }

            Commands::Switch { target } => {
                let parts: Vec<&str> = target.split('@').collect();
                if parts.len() != 2 {
                    error!("cli.switch.invalid_format", target);
                    return Ok(());
                }

                let pkg_name = parts[0];
                let pkg_version = parts[1];

                match semver::Version::parse(pkg_version) {
                    Ok(version) => {
                        info!("cli.switch.switching", pkg_name, pkg_version);
                        service.switch_version(pkg_name, version).await?;
                        info!("cli.switch.success", pkg_name, pkg_version);
                    }
                    Err(e) => {
                        error!("cli.switch.invalid_version", pkg_version, e);
                    }
                }
            }

            Commands::Completions { shell } => match shell.to_lowercase().as_str() {
                "bash" => generate(Bash, &mut Cli::command(), "uhpm", &mut io::stdout()),
                "zsh" => generate(Zsh, &mut Cli::command(), "uhpm", &mut io::stdout()),
                "fish" => generate(Fish, &mut Cli::command(), "uhpm", &mut io::stdout()),
                other => println!("Unsupported shell: {}", other),
            },
        }

        Ok(())
    }
}
############### ENDOFFILE ########################

############### main.rs #########################
use clap::Parser;
use dirs;
use uhpm::cli::Cli;
use uhpm::db::PackageDB;
use uhpm::service::PackageService;
use uhpm::{debug, info};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt::init();

    let mut db_path = dirs::home_dir().ok_or("Could not determine home directory")?;
    db_path.push(".uhpm");
    db_path.push("packages.db");

    debug!("main.info.using_package_db");
    debug!("main.info.db_path_is", db_path.display());

    let package_db = PackageDB::new(&db_path)?.init().await?;
    let package_service = PackageService::new(package_db);

    info!("main.info.uhpm_started");

    let args = Cli::parse();
    args.run(&package_service).await?;

    Ok(())
}
############### ENDOFFILE ########################

############### service.rs #########################
use crate::db::PackageDB;
use crate::error::{ConfigError, UhpmError};
use crate::fetcher;
use crate::package::{installer, remover, switcher, updater};
use crate::repo::{RepoDB, parse_repos};
use semver::Version;
use std::path::{Path, PathBuf};

pub struct PackageService {
    db: PackageDB,
}

impl PackageService {
    pub fn new(db: PackageDB) -> Self {
        Self { db }
    }

    pub async fn install_from_file(&self, path: &Path) -> Result<(), UhpmError> {
        installer::install(path, &self.db).await?;
        Ok(())
    }

    pub async fn install_from_repo(
        &self,
        package_name: &str,
        version: Option<&str>,
    ) -> Result<(), UhpmError> {
        let repos = self.load_repositories().await?;
        let mut urls_to_download = Vec::new();

        for (repo_name, repo_path) in &repos {
            let repo_db_path = self.get_repo_db_path(repo_path)?;
            if !repo_db_path.exists() {
                tracing::warn!("Repository database not found: {}", repo_name);
                continue;
            }

            let repo_db = RepoDB::new(&repo_db_path).await?;
            let packages = repo_db.list_packages().await?;

            for (name, pkg_version) in packages {
                if name == package_name {
                    if version.is_none() || version.unwrap() == pkg_version {
                        if let Ok(url) = repo_db.get_package(&name, &pkg_version).await {
                            urls_to_download.push(url);
                            break;
                        }
                    }
                }
            }
        }

        if urls_to_download.is_empty() {
            return Err(UhpmError::NotFound(format!(
                "Package {} not found in repositories",
                package_name
            )));
        }

        fetcher::fetch_and_install_parallel(&urls_to_download, &self.db).await?;
        Ok(())
    }

    pub async fn remove_package(&self, package_name: &str) -> Result<(), UhpmError> {
        remover::remove(package_name, &self.db).await?;
        Ok(())
    }

    pub async fn remove_package_version(
        &self,
        package_name: &str,
        version: &str,
    ) -> Result<(), UhpmError> {
        remover::remove_by_version(package_name, version, &self.db).await?;
        Ok(())
    }

    pub async fn update_package(&self, package_name: &str) -> Result<(), UhpmError> {
        updater::update_package(package_name, &self.db).await?;
        Ok(())
    }

    pub async fn switch_version(
        &self,
        package_name: &str,
        version: Version,
    ) -> Result<(), UhpmError> {
        switcher::switch_version(package_name, version, &self.db).await?;
        Ok(())
    }

    pub async fn list_packages(&self) -> Result<Vec<(String, String, bool)>, UhpmError> {
        self.db.list_packages().await.map_err(UhpmError::from)
    }

    async fn load_repositories(
        &self,
    ) -> Result<std::collections::HashMap<String, String>, UhpmError> {
        let repos_path = dirs::home_dir()
            .ok_or_else(|| {
                UhpmError::Config(ConfigError::NotFound(
                    "Home directory not found".to_string(),
                ))
            })?
            .join(".uhpm/repos.ron");

        parse_repos(&repos_path).map_err(|e| UhpmError::Repository(e.into()))
    }

    fn get_repo_db_path(&self, repo_path: &str) -> Result<PathBuf, UhpmError> {
        let path = if let Some(stripped) = repo_path.strip_prefix("file://") {
            stripped
        } else {
            repo_path
        };
        Ok(PathBuf::from(path).join("packages.db"))
    }
}
############### ENDOFFILE ########################

############### uhpmk.rs #########################
//! # UHPM Package Maker (uhpmk)
//!
//! This binary crate provides a command-line utility for creating and packaging UHPM packages.

use clap::{Parser, Subcommand};
use flate2::Compression;
use flate2::write::GzEncoder;
use std::fs::File;
use std::path::PathBuf;
use std::process::Command;
use tar::Builder;
use uhpm::package::{Package, meta_parser};
use uhpm::symlist;
use uhpm::{error, info};

/// CLI interface for UHPM Package Maker
#[derive(Parser)]
#[command(
    name = "uhpmk",
    version = "1.0",
    about = "Universal Home Package Maker"
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

/// Available subcommands for uhpmk
#[derive(Subcommand)]
enum Commands {
    /// Initialize a new package template
    Init {
        #[arg(short, long)]
        out_dir: Option<PathBuf>,
    },

    /// Build a package using its build script
    Build {
        #[arg(value_name = "PATH")]
        package_dir: PathBuf,
        #[arg(short, long)]
        pack: bool,
        #[arg(short, long)]
        install: bool,
        #[arg(short, long)]
        out_dir: Option<PathBuf>,
    },

    /// Package a directory into a .uhp archive
    Pack {
        #[arg(value_name = "PATH")]
        package_dir: PathBuf,
        #[arg(short, long)]
        out_dir: Option<PathBuf>,
    },
}

#[derive(thiserror::Error, Debug)]
enum PackerError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Package error: {0}")]
    Package(String),
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt::init();
    let cli = Cli::parse();

    match cli.command {
        Commands::Init { out_dir } => {
            let out_dir = out_dir.unwrap_or(std::env::current_dir()?);

            let pkg = Package::template();
            let out_path = out_dir.join("uhp.toml");
            pkg.save_to_toml(&out_path)?;
            info!("uhpmk.init.uhp_toml_created", out_path.display());

            let symlist_path = out_dir.join("symlist");
            symlist::save_template(&symlist_path)?;
            info!("uhpmk.init.symlist_created", symlist_path.display());
        }

        Commands::Build {
            package_dir,
            pack,
            install,
            out_dir,
        } => {
            if !package_dir.exists() {
                error!("uhpmk.build.dir_not_found", package_dir.display());
                return Err("Package directory not found".into());
            }

            let build_script_path = package_dir.join("uhpbuild");
            if !build_script_path.exists() {
                error!("uhpmk.build.script_not_found", build_script_path.display());
                return Err("Build script not found".into());
            }

            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let mut perms = std::fs::metadata(&build_script_path)?.permissions();
                perms.set_mode(0o755);
                std::fs::set_permissions(&build_script_path, perms)?;
            }

            info!("uhpmk.build.executing_script", build_script_path.display());

            let status = Command::new(&build_script_path)
                .current_dir(&package_dir)
                .status()?;

            if !status.success() {
                error!("uhpmk.build.script_failed", status.code().unwrap_or(-1));
                return Err("Build script execution failed".into());
            }

            info!("uhpmk.build.script_completed");

            if pack {
                let out_dir = out_dir.unwrap_or(std::env::current_dir()?);
                let pkg_path = packer(package_dir.join("package"), out_dir)?;
                if install {
                    let mut db_path =
                        dirs::home_dir().ok_or("Could not determine home directory")?;
                    db_path.push(".uhpm");
                    db_path.push("packages.db");
                    let package_db = uhpm::db::PackageDB::new(&db_path)?.init().await?;
                    uhpm::package::installer::install(&pkg_path, &package_db).await?;
                }
            }
        }

        Commands::Pack {
            package_dir,
            out_dir,
        } => {
            let out_dir = out_dir.unwrap_or(std::env::current_dir()?);
            packer(package_dir, out_dir)?;
        }
    }

    Ok(())
}

fn packer(package_dir: PathBuf, out_dir: PathBuf) -> Result<PathBuf, Box<dyn std::error::Error>> {
    let meta_path = package_dir.join("uhp.toml");
    if !meta_path.exists() {
        error!("uhpmk.pack.meta_not_found", meta_path.display());
        return Err(PackerError::Package(format!(
            "uhp.toml not found in {}",
            package_dir.display()
        ))
        .into());
    }

    let pkg: Package = meta_parser(&meta_path)
        .map_err(|e| PackerError::Package(format!("Failed to parse package metadata: {}", e)))?;

    let filename = format!("{}-{}.uhp", pkg.name(), pkg.version());
    let archive_path = out_dir.join(&filename);

    let tar_gz = File::create(&archive_path)?;
    let enc = GzEncoder::new(tar_gz, Compression::default());
    let mut tar = Builder::new(enc);

    tar.append_dir_all(".", &package_dir)?;
    tar.finish()?;

    info!("uhpmk.pack.package_packed", archive_path.display());
    Ok(archive_path)
}
############### ENDOFFILE ########################

############### installer.rs #########################
//! # Package Installer Module
//!
//! This module provides functionality for installing UHPM packages from `.uhp` archive files.
//! It handles package extraction, metadata parsing, symlink creation, and database registration.
//!
//! ## Main Components
//!
//! - [`InstallError`]: Enumeration of possible installation errors
//! - [`install()`]: Main installation function for package archives
//! - [`create_symlinks()`]: Creates symbolic links for package files
//! - [`unpack()`]: Extracts package archives to temporary directory
//!
//! ## Installation Process
//!
//! 1. **Extraction**: Package archive is extracted to temporary directory
//! 2. **Metadata Parsing**: Package metadata is read from `uhp.toml` file
//! 3. **Version Check**: Verifies if package is already installed
//! 4. **Directory Setup**: Creates package directory in UHPM home
//! 5. **Symlink Creation**: Creates symbolic links based on `symlist`
//! 6. **Database Registration**: Records package info in package database
//!
//! ## Error Handling
//!
//! Errors are categorized into I/O errors and metadata parsing errors,
//! both wrapped in the [`InstallError`] enumeration.

use crate::db::PackageDB;
use crate::error::UhpmError;
use crate::package::Package;
use crate::symlist;
use crate::{debug, info, warn};
use flate2::read::GzDecoder;
use std::fs;
use std::path::{Path, PathBuf};
use tar::Archive;

/// Errors that can occur during package installation
#[derive(Debug)]
pub enum InstallError {
    /// I/O error during file operations
    Io(std::io::Error),
    /// Error parsing package metadata
    Meta(crate::package::MetaParseError),
}

impl From<std::io::Error> for InstallError {
    fn from(e: std::io::Error) -> Self {
        InstallError::Io(e)
    }
}

impl From<crate::package::MetaParseError> for InstallError {
    fn from(e: crate::package::MetaParseError) -> Self {
        InstallError::Meta(e)
    }
}

/// Installs a package from a `.uhp` archive file
///
/// # Arguments
/// * `pkg_path` - Path to the package archive file
/// * `db` - Reference to the package database
///
/// # Returns
/// `Result<(), InstallError>` - Success or error result
///
/// # Process
/// 1. Extracts package to temporary directory
/// 2. Parses package metadata from `uhp.toml`
/// 3. Checks if package is already installed
/// 4. Moves package to permanent location
/// 5. Creates symbolic links for package files
/// 6. Updates package database
pub async fn install(pkg_path: &Path, db: &PackageDB) -> Result<(), UhpmError> {
    info!("installer.install.starting", pkg_path.display());

    let unpacked = unpack(pkg_path)?;
    debug!("installer.install.unpacked", unpacked.display());

    let meta_path = unpacked.join("uhp.toml");
    debug!("installer.install.reading_meta", meta_path.display());
    let package_meta: Package = crate::package::meta_parser(&meta_path)?;
    info!(
        "installer.install.package_info",
        package_meta.name(),
        package_meta.version()
    );

    let pkg_name = package_meta.name();
    let version = package_meta.version();

    let already_installed = db.is_installed(pkg_name).await.unwrap();
    if let Some(installed_version) = &already_installed {
        info!(
            "installer.install.already_installed",
            pkg_name, installed_version
        );
        if installed_version == version {
            info!("installer.install.same_version_skipped");
            return Ok(());
        }
    }

    let package_root = dirs::home_dir()
        .unwrap()
        .join(".uhpm/packages")
        .join(format!("{}-{}", pkg_name, version));
    debug!("installer.install.package_root", package_root.display());

    if package_root.exists() {
        debug!(
            "installer.install.removing_existing",
            package_root.display()
        );
        fs::remove_dir_all(&package_root)?;
    }
    fs::create_dir_all(&package_root)?;
    debug!("installer.install.created_dir", package_root.display());

    fs::rename(&unpacked, &package_root)?;
    debug!("installer.install.moved_package", package_root.display());

    let mut installed_files = Vec::new();
    match already_installed {
        None => {
            info!("installer.install.creating_symlinks");
            installed_files = create_symlinks(&package_root)?;
        }
        Some(_) => {
            info!("installer.install.updating_version");
        }
    }

    let installed_files_str: Vec<String> = installed_files
        .iter()
        .map(|p| p.to_string_lossy().to_string())
        .collect();
    info!(
        "installer.install.adding_to_db",
        pkg_name,
        installed_files_str.len()
    );
    db.add_package_full(&package_meta, &installed_files_str)
        .await
        .unwrap();
    db.set_current_version(&package_meta.name(), &package_meta.version().to_string())
        .await
        .unwrap();

    info!("installer.install.success", pkg_name);
    Ok(())
}

/// Creates symbolic links for package files based on symlist configuration
///
/// # Arguments
/// * `package_root` - Path to the package directory
///
/// # Returns
/// `Result<Vec<PathBuf>, std::io::Error>` - List of created symlink paths or error
///
/// # Process
/// 1. Loads symlink configuration from `symlist`
/// 2. Creates parent directories for symlink targets
/// 3. Removes existing files at target locations
/// 4. Creates symbolic links from package files to target locations
pub fn create_symlinks(package_root: &Path) -> Result<Vec<PathBuf>, std::io::Error> {
    let mut installed_files = Vec::new();

    let symlist_path = package_root.join("symlist");
    debug!("installer.symlinks.loading", symlist_path.display());

    match symlist::load_symlist(&symlist_path, &package_root) {
        Ok(symlinks) => {
            for (src_rel, dst_abs) in symlinks {
                let src_abs = package_root.join(&src_rel);
                debug!(
                    "installer.symlinks.processing",
                    src_abs.display(),
                    dst_abs.display()
                );

                if !src_abs.exists() {
                    warn!("installer.symlinks.src_not_found", src_abs.display());
                    continue;
                }

                if let Some(parent) = dst_abs.parent() {
                    fs::create_dir_all(parent)?;
                    debug!("installer.symlinks.created_parent", parent.display());
                }

                if dst_abs.exists() {
                    fs::remove_file(&dst_abs)?;
                    debug!("installer.symlinks.removed_existing", dst_abs.display());
                }

                std::os::unix::fs::symlink(&src_abs, &dst_abs)?;
                debug!(
                    "installer.symlinks.created_link",
                    dst_abs.display(),
                    src_abs.display()
                );
                installed_files.push(dst_abs);
            }
        }
        Err(e) => {
            warn!("installer.symlinks.load_failed", e);
        }
    }

    debug!("installer.symlinks.total_created", installed_files.len());
    Ok(installed_files)
}

/// Extracts a package archive to a temporary directory
///
/// # Arguments
/// * `pkg_path` - Path to the package archive file
///
/// # Returns
/// `Result<PathBuf, std::io::Error>` - Path to extracted directory or error
///
/// # Process
/// 1. Validates file extension (.uhp)
/// 2. Creates temporary extraction directory
/// 3. Extracts tar.gz archive contents
/// 4. Returns path to extracted directory
fn unpack(pkg_path: &Path) -> Result<PathBuf, std::io::Error> {
    if pkg_path.extension().and_then(|s| s.to_str()) != Some("uhp") {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "Package must have .uhp extension",
        ));
    }

    let tmp_dir = dirs::home_dir().unwrap().join(".uhpm/tmp");
    fs::create_dir_all(&tmp_dir)?;

    let package_name = pkg_path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("unknown_package");
    let unpack_dir = tmp_dir.join(package_name);

    if unpack_dir.exists() {
        fs::remove_dir_all(&unpack_dir)?;
    }
    fs::create_dir_all(&unpack_dir)?;

    debug!(
        "installer.unpack.unpacking",
        pkg_path.display(),
        unpack_dir.display()
    );

    let tar_gz = fs::File::open(pkg_path)?;
    let decompressor = flate2::read::GzDecoder::new(tar_gz);
    let mut archive = tar::Archive::new(decompressor);
    archive.unpack(&unpack_dir)?;

    debug!("installer.unpack.done", unpack_dir.display());
    Ok(unpack_dir)
}

pub async fn install_at(
    pkg_path: &Path,
    db: &PackageDB,
    uhpm_root: &Path,
) -> Result<(), crate::package::installer::InstallError> {
    info!("installer.install_at.starting", pkg_path.display());

    let unpacked = unpack_at(pkg_path, uhpm_root)?;
    debug!("installer.install_at.unpacked", unpacked.display());

    let meta_path = unpacked.join("uhp.toml"); // Исправлено: uhp.ron -> uhp.toml
    debug!("installer.install_at.reading_meta", meta_path.display());
    let package_meta: Package = crate::package::meta_parser(&meta_path)?;
    info!(
        "installer.install_at.package_info",
        package_meta.name(),
        package_meta.version()
    );

    let pkg_name = package_meta.name();
    let version = package_meta.version();

    let already_installed = db.is_installed(pkg_name).await.unwrap();
    if let Some(installed_version) = &already_installed {
        info!(
            "installer.install_at.already_installed",
            pkg_name, installed_version
        );
        if installed_version == version {
            info!("installer.install_at.same_version_skipped");
            return Ok(());
        }
    }

    let package_root = uhpm_root
        .join("packages")
        .join(format!("{}-{}", pkg_name, version));
    debug!("installer.install_at.package_root", package_root.display());

    if package_root.exists() {
        debug!(
            "installer.install_at.removing_existing",
            package_root.display()
        );
        fs::remove_dir_all(&package_root)?;
    }
    fs::create_dir_all(&package_root)?;
    debug!("installer.install_at.created_dir", package_root.display());

    fs::rename(&unpacked, &package_root)?;
    debug!("installer.install_at.moved_package", package_root.display());

    let mut installed_files = Vec::new();
    match already_installed {
        None => {
            info!("installer.install_at.creating_symlinks");
            installed_files = create_symlinks(&package_root)?;
        }
        Some(_) => {
            info!("installer.install_at.updating_version");
        }
    }

    let installed_files_str: Vec<String> = installed_files
        .iter()
        .map(|p| p.to_string_lossy().to_string())
        .collect();
    info!(
        "installer.install_at.adding_to_db",
        pkg_name,
        installed_files_str.len()
    );
    db.add_package_full(&package_meta, &installed_files_str)
        .await
        .unwrap();
    db.set_current_version(&package_meta.name(), &package_meta.version().to_string())
        .await
        .unwrap();

    info!("installer.install_at.success", pkg_name);
    Ok(())
}

/// Распаковка пакета в указанную директорию UHPM
pub fn unpack_at(pkg_path: &Path, uhpm_root: &Path) -> Result<PathBuf, std::io::Error> {
    if pkg_path.extension().and_then(|s| s.to_str()) != Some("uhp") {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "Package must have .uhp extension",
        ));
    }

    let tmp_dir = uhpm_root.join("tmp");
    fs::create_dir_all(&tmp_dir)?;

    let package_name = pkg_path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("unknown_package");
    let unpack_dir = tmp_dir.join(package_name);

    if unpack_dir.exists() {
        fs::remove_dir_all(&unpack_dir)?;
    }
    fs::create_dir_all(&unpack_dir)?;

    debug!(
        "installer.unpack_at.unpacking",
        pkg_path.display(),
        unpack_dir.display()
    );

    let tar_gz = fs::File::open(pkg_path)?;
    let decompressor = GzDecoder::new(tar_gz);
    let mut archive = Archive::new(decompressor);
    archive.unpack(&unpack_dir)?;

    debug!("installer.unpack_at.done", unpack_dir.display());
    Ok(unpack_dir)
}
############### ENDOFFILE ########################

############### mocks.rs #########################
//! # Mocks for UHPM Package System
//!
//! This module provides mock implementations of database, unpacker, and symlink creator
//! for testing UHPM package installation logic without touching real filesystem or database.

use crate::db::PackageDBTrait;
use crate::package::Package;
use crate::package::installer::{SymlinkCreatorTrait, UnpackerTrait};
use async_trait::async_trait;
use semver::Version;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::sync::Mutex;

/// ----------------------
/// Mock Database
/// ----------------------
#[derive(Default, Clone)]
pub struct MockDB {
    pub versions: Arc<Mutex<HashMap<String, String>>>,
}

#[async_trait]
impl PackageDBTrait for MockDB {
    async fn is_installed(&self, name: &str) -> Result<Option<Version>, sqlx::Error> {
        let versions = self.versions.lock().await;
        Ok(versions.get(name).map(|v| Version::parse(v).unwrap()))
    }

    async fn add_package_full(&self, pkg: &Package, _files: &[String]) -> Result<(), sqlx::Error> {
        let mut versions = self.versions.lock().await;
        versions.insert(pkg.name().to_string(), pkg.version().to_string());
        Ok(())
    }

    async fn set_current_version(&self, name: &str, version: &str) -> Result<(), sqlx::Error> {
        let mut versions = self.versions.lock().await;
        versions.insert(name.to_string(), version.to_string());
        Ok(())
    }

    async fn get_installed_files(&self, _pkg_name: &str) -> Result<Vec<String>, sqlx::Error> {
        Ok(Vec::new())
    }
}

/// ----------------------
/// Mock Unpacker
/// ----------------------
#[derive(Clone)]
pub struct MockUnpacker {
    pub path: PathBuf,
}

#[async_trait]
impl UnpackerTrait for MockUnpacker {
    async fn unpack(&self, _pkg_path: &Path) -> Result<PathBuf, std::io::Error> {
        Ok(self.path.clone())
    }
}

/// ----------------------
/// Mock Symlink Creator
/// ----------------------
#[derive(Clone)]
pub struct MockSymlink {
    pub files: Vec<PathBuf>,
}

impl SymlinkCreatorTrait for MockSymlink {
    fn create_symlinks(&self, _package_root: &Path) -> Result<Vec<PathBuf>, std::io::Error> {
        Ok(self.files.clone())
    }
}
############### ENDOFFILE ########################

############### switcher.rs #########################
//! # Package Version Switcher
//!
//! This module provides functionality to switch between different installed
//! versions of a package. It updates symbolic links to point to the files
//! of the desired version and updates the database record for the "current"
//! version.
//!
//! ## Responsibilities
//! - Remove symlinks of the currently active version.
//! - Validate existence of the target version directory.
//! - Create symlinks for the target version.
//! - Update the package database with the new current version.
//!
//! Errors are unified under [`SwitchError`] for consistency.

use crate::db::PackageDB;
use crate::error::SwitchError;
use crate::package::installer::create_symlinks;
use crate::{info, warn};
use semver::Version;
use std::path::PathBuf;

/// Errors that may occur when switching package versions.
// #[derive(Debug)]
// pub enum SwitchError {
//     /// Filesystem or I/O error.
//     Io(std::io::Error),
//     /// Database error from `sqlx`.
//     Db(sqlx::Error),
//     /// Target package directory does not exist.
//     MissingPackageDir(PathBuf),
//     /// Error while parsing or processing `symlist.ron`.
//     Symlist(crate::symlist::SymlistError),
//     /// Requested package version not found in database.
//     PackageNotFound(String, Version),
// }

// impl From<std::io::Error> for SwitchError {
//     fn from(e: std::io::Error) -> Self {
//         SwitchError::Io(e)
//     }
// }
// impl From<sqlx::Error> for SwitchError {
//     fn from(e: sqlx::Error) -> Self {
//         SwitchError::Db(e)
//     }
// }
// impl From<crate::symlist::SymlistError> for SwitchError {
//     fn from(e: crate::symlist::SymlistError) -> Self {
//         SwitchError::Symlist(e)
//     }
// }

/// Switch the active version of a package.
///
/// # Arguments
/// - `pkg_name`: The package name.
/// - `target_version`: The version to switch to.
/// - `db`: Reference to the [`PackageDB`] instance.
///
/// # Workflow
/// 1. Remove symlinks of the current active version (if present).
///    - Ensures only symlinks created by UHPM are removed.
///    - Non-matching symlinks or regular files are skipped safely.
/// 2. Verify that the target package directory exists.
///    - If not, returns [`SwitchError::MissingPackageDir`].
/// 3. Create symlinks for the target version using [`create_symlinks`].
/// 4. Update the package database with the new current version.
///
/// # Errors
/// Returns [`SwitchError`] if:
/// - Filesystem operations (removing files, reading symlinks) fail.
/// - Database operations fail.
/// - `symlist.ron` is missing or invalid.
/// - Target package directory does not exist.
///
/// # Logging
/// - Logs removed or skipped symlinks from the old version.
/// - Logs the switch to the new version when successful.
pub async fn switch_version(
    pkg_name: &str,
    target_version: Version,
    db: &PackageDB,
) -> Result<(), SwitchError> {
    // Get home directory safely
    let home_dir = dirs::home_dir().ok_or_else(|| {
        SwitchError::Io(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "HOME directory not found",
        ))
    })?;

    // Remove symlinks from the current version if available
    if let Some(current_package) = db.get_current_package(pkg_name).await? {
        let current_version_str = current_package.version().to_string();
        let current_pkg_dir = home_dir
            .join(".uhpm/packages")
            .join(format!("{}-{}", pkg_name, current_version_str));

        if current_pkg_dir.exists() {
            let symlist_path = current_pkg_dir.join("symlist.ron");
            match crate::symlist::load_symlist(&symlist_path, &current_pkg_dir) {
                Ok(symlinks) => {
                    for (src_abs, dst_abs) in symlinks {
                        if !dst_abs.exists() {
                            continue;
                        }

                        match std::fs::symlink_metadata(&dst_abs) {
                            Ok(meta) if meta.file_type().is_symlink() => {
                                match std::fs::read_link(&dst_abs) {
                                    Ok(link_target) if link_target == src_abs => {
                                        if let Err(e) = std::fs::remove_file(&dst_abs) {
                                            warn!(
                                                "package.switcher.remove_symlink_failed",
                                                dst_abs.display(),
                                                e
                                            );
                                        } else {
                                            info!(
                                                "package.switcher.removed_old_symlink",
                                                dst_abs.display()
                                            );
                                        }
                                    }
                                    Ok(link_target) => {
                                        info!(
                                            "package.switcher.skipping_symlink_wrong_target",
                                            dst_abs.display(),
                                            src_abs.display(),
                                            link_target.display()
                                        );
                                    }
                                    Err(e) => {
                                        warn!(
                                            "package.switcher.read_symlink_failed",
                                            dst_abs.display(),
                                            e
                                        );
                                    }
                                }
                            }
                            Ok(_) => {
                                info!("package.switcher.skipping_not_symlink", dst_abs.display())
                            }
                            Err(e) => {
                                warn!("package.switcher.metadata_failed", dst_abs.display(), e)
                            }
                        }
                    }
                }
                Err(crate::symlist::SymlistError::Io(ref io_err))
                    if io_err.kind() == std::io::ErrorKind::NotFound =>
                {
                    info!("package.switcher.symlist_not_found_cleanup_skip");
                }
                Err(e) => return Err(SwitchError::Symlist(e)),
            }
        } else {
            info!(
                "package.switcher.package_dir_not_found_cleanup_skip",
                current_pkg_dir.display()
            );
        }
    } else {
        info!("package.switcher.no_current_version_cleanup_skip");
    }

    // Verify target package directory exists
    let new_pkg_dir = home_dir
        .join(".uhpm/packages")
        .join(format!("{}-{}", pkg_name, target_version));

    if !new_pkg_dir.exists() {
        return Err(SwitchError::MissingPackageDir(new_pkg_dir));
    }

    // Create symlinks for the new version
    create_symlinks(&new_pkg_dir)?;

    // Update database with the new current version
    db.set_current_version(pkg_name, &target_version.to_string())
        .await?;

    info!("package.switcher.switch_success", pkg_name, target_version);

    Ok(())
}
############### ENDOFFILE ########################

############### updater.rs #########################
//! # Package Updater
//!
//! This module provides functionality to check for and install newer versions
//! of installed packages from configured repositories.

use crate::db::PackageDB;
use crate::error::UpdaterError;
use crate::fetcher;
use crate::repo::{RepoDB, parse_repos};
use crate::{error, info, warn};
use semver::Version;
use std::path::Path;

/// Errors that may occur during package update.

/// Check for updates and return download URL if newer version exists
pub async fn check_for_update(
    pkg_name: &str,
    package_db: &PackageDB,
) -> Result<String, UpdaterError> {
    // Step 1: check installed version
    let installed_version = package_db.get_package_version(pkg_name).await?;
    if installed_version.is_none() {
        warn!("package.updater.package_not_installed", pkg_name);
        return Err(UpdaterError::NotFound(pkg_name.to_string()));
    }

    let installed_version = installed_version.unwrap();
    info!(
        "package.updater.installed_version",
        pkg_name, &installed_version
    );

    // Step 2: parse repository configuration
    let repos_path = dirs::home_dir().unwrap().join(".uhpm/repos.ron");
    let repos = parse_repos(&repos_path).unwrap();

    let mut latest_url = None;
    let mut latest_version: Option<Version> = None;

    // Step 3: iterate through repositories
    for (repo_name, repo_path) in repos {
        let repo_path = repo_path
            .strip_prefix("file://")
            .unwrap_or(&repo_path)
            .to_string();
        let repo_db_path = std::path::Path::new(&repo_path).join("packages.db");

        if !repo_db_path.exists() {
            warn!("package.updater.repo_db_not_found", repo_name);
            continue;
        }

        let repo_db = RepoDB::new(&repo_db_path).await?;
        let pkg_list = repo_db.list_packages().await?;

        for (name, ver_str) in pkg_list {
            if name == pkg_name {
                let ver = Version::parse(&ver_str).unwrap_or(Version::new(0, 0, 0));
                let inst_ver = Version::parse(&installed_version).unwrap_or(Version::new(0, 0, 0));
                if ver > inst_ver {
                    latest_version = Some(ver);
                    latest_url = Some(repo_db.get_package(&name, &ver_str).await.unwrap());
                }
            }
        }
    }

    // Return URL if newer version found
    latest_url.ok_or_else(|| UpdaterError::NoNewVersion(pkg_name.to_string()))
}

/// Update package from local file
pub async fn update_from_file(pkg_path: &Path, package_db: &PackageDB) -> Result<(), UpdaterError> {
    info!("package.updater.updating_from_file", pkg_path.display());

    // Convert Path to string URL for fetcher
    let url = format!("file://{}", pkg_path.display());

    // Фетчер сам должен уметь извлекать имя пакета из метаданных
    fetcher::fetch_and_install_parallel(&[url], package_db).await?;

    info!(
        "package.updater.update_from_file_success",
        pkg_path.display()
    );
    Ok(())
}

/// Update a package to the latest version available in repositories.
pub async fn update_package(pkg_name: &str, package_db: &PackageDB) -> Result<(), UpdaterError> {
    // Check for updates
    let download_url = check_for_update(pkg_name, package_db).await?;

    // Download and install
    fetcher::fetch_and_install_parallel(&[download_url], package_db).await?;
    info!("package.updater.update_success", pkg_name);

    Ok(())
}
############### ENDOFFILE ########################

############### remover.rs #########################
//! # Package Remover Module
//!
//! This module provides functionality for removing installed UHPM packages.
//! It handles package file cleanup, symlink removal, and database record deletion.
//!
//! ## Main Components
//!
//! - [`DeleteError`]: Enumeration of possible removal errors
//! - [`remove()`]: Main function for package removal
//!
//! ## Removal Process
//!
//! 1. **Database Check**: Verifies if package exists in database
//! 2. **Directory Removal**: Deletes package installation directory
//! 3. **File Cleanup**: Removes all installed files and symlinks
//! 4. **Database Update**: Removes package record from database
//!
//! ## Error Handling
//!
//! Errors are categorized into I/O errors and database errors,
//! both wrapped in the [`DeleteError`] enumeration.

use crate::db::PackageDB;
use crate::error::UhpmError;
use crate::package::switcher;
use crate::{error, info, warn};

/// Errors that can occur during package removal
#[derive(Debug)]
pub enum DeleteError {
    /// I/O error during file operations
    Io(std::io::Error),
    /// Database error during record deletion
    Db(sqlx::Error),
}

impl From<std::io::Error> for DeleteError {
    fn from(e: std::io::Error) -> Self {
        DeleteError::Io(e)
    }
}

impl From<sqlx::Error> for DeleteError {
    fn from(e: sqlx::Error) -> Self {
        DeleteError::Db(e)
    }
}

/// Removes an installed package and all its associated files
///
/// # Arguments
/// * `pkg_name` - Name of the package to remove
/// * `db` - Reference to the package database
///
/// # Returns
/// `Result<(), DeleteError>` - Success or error result
///
/// # Process
/// 1. Checks if package exists in database
/// 2. Removes package installation directory
/// 3. Removes all installed files and symlinks
/// 4. Deletes package record from database
///
/// # Notes
/// - If package directory doesn't exist, removal continues with file cleanup
/// - Non-existent files are skipped during cleanup
/// - Database record is always removed if package exists in database
pub async fn remove(pkg_name: &str, db: &PackageDB) -> Result<(), UhpmError> {
    let version = db.get_package_version(pkg_name).await?;
    if version.is_none() {
        warn!("uhpm.remove.pkg_not_found_db", pkg_name);
        return Ok(());
    }
    let version = version.unwrap();

    remove_by_version(pkg_name, &version, db).await?;
    Ok(())
}

pub async fn remove_by_version(
    pkg_name: &str,
    version: &str,
    db: &PackageDB,
) -> Result<(), UhpmError> {
    info!("uhpm.remove.attempting_remove", pkg_name, &version);

    let mut pkg_dir = dirs::home_dir().unwrap();
    pkg_dir.push(".uhpm/packages");
    pkg_dir.push(format!("{}-{}", pkg_name, version));

    if pkg_dir.exists() {
        std::fs::remove_dir_all(&pkg_dir)?;
        info!("uhpm.remove.pkg_dir_removed", pkg_dir.display());
    } else {
        warn!("uhpm.remove.pkg_dir_not_found", pkg_name, pkg_dir.display());
    }

    let files: Vec<String> = db.get_installed_files(pkg_name).await?;
    for f in files {
        let path = std::path::PathBuf::from(f);
        if path.exists() {
            if path.is_dir() {
                std::fs::remove_dir_all(&path)?;
            } else {
                std::fs::remove_file(&path)?;
            }
            info!("uhpm.remove.file_removed", path.display());
        }
    }

    db.remove_package(pkg_name).await?;
    let lastpkg = db.get_latest_package_version(pkg_name).await?;
    if lastpkg.is_some() {
        match switcher::switch_version(pkg_name, lastpkg.unwrap().version().to_owned(), db).await {
            Ok(_) => {
                info!("remover.remove_by_version.succes_switch_after_remove");
            }
            Err(e) => {
                error!("remover.remove_by_version.switch_after_remove_error", e);
            }
        }
    }
    info!("uhpm.remove.pkg_entry_removed", pkg_name);

    Ok(())
}
############### ENDOFFILE ########################

