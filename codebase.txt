############### config.rs #########################
//! # Configuration Module
//!
//! This module defines the configuration structure for UHPM (Universal Home Package Manager).
//! It handles loading, saving, and managing configuration settings including repository URLs
//! and update sources.

use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
use thiserror::Error;

/// Errors that may occur while working with configuration.
#[derive(Error, Debug)]
pub enum ConfigError {
    /// Filesystem error.
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    /// RON parsing error.
    #[error("RON parse error: {0}")]
    Ron(#[from] ron::error::SpannedError),

    /// RON error.
    #[error("RON error: {0}")]
    RonError(#[from] ron::Error),

    /// Configuration file not found.
    #[error("Configuration file not found: {0}")]
    NotFound(String),
}

/// Represents the UHPM configuration.
///
/// Contains settings for package management including update sources
/// and repository configuration.
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct Config {
    /// URL source for UHPM updates
    pub update_source: String,
}

impl Config {
    /// Creates a new configuration with default values.
    pub fn new() -> Self {
        Self {
            update_source: String::new(),
        }
    }

    /// Loads configuration from the default location (`~/.uhpm/config.ron`).
    pub fn load() -> Result<Self, ConfigError> {
        let config_path = Self::get_config_path()?;
        Self::load_from_path(&config_path)
    }

    /// Loads configuration from a specific path.
    pub fn load_from_path<P: AsRef<Path>>(path: P) -> Result<Self, ConfigError> {
        let path_ref = path.as_ref();
        if !path_ref.exists() {
            return Err(ConfigError::NotFound(
                path_ref.to_string_lossy().to_string(),
            ));
        }

        let content = fs::read_to_string(path_ref)?;
        let config: Config = ron::from_str(&content)?;
        Ok(config)
    }

    /// Saves configuration to the default location (`~/.uhpm/config.ron`).
    pub fn save(&self) -> Result<(), ConfigError> {
        let config_path = Self::get_config_path()?;
        self.save_to_path(&config_path)
    }

    /// Saves configuration to a specific path.
    pub fn save_to_path<P: AsRef<Path>>(&self, path: P) -> Result<(), ConfigError> {
        let path_ref = path.as_ref();

        // Create directory if it doesn't exist
        if let Some(parent) = path_ref.parent() {
            fs::create_dir_all(parent)?;
        }

        let pretty = ron::ser::PrettyConfig::new();
        let ron_str = ron::ser::to_string_pretty(self, pretty)?;
        fs::write(path_ref, ron_str)?;

        Ok(())
    }

    /// Returns the default configuration path (`~/.uhpm/config.ron`).
    pub fn get_config_path() -> Result<PathBuf, ConfigError> {
        let home_dir = dirs::home_dir()
            .ok_or_else(|| ConfigError::NotFound("Home directory not found".to_string()))?;

        let mut config_path = home_dir;
        config_path.push(".uhpm");
        config_path.push("config.ron");

        Ok(config_path)
    }

    /// Creates a default configuration file if it doesn't exist.
    pub fn ensure_default() -> Result<(), ConfigError> {
        let config_path = Self::get_config_path()?;

        if !config_path.exists() {
            let default_config = Config::new();
            default_config.save()?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_config_creation() {
        let config = Config::new();
        assert!(config.update_source.is_empty());
    }

    #[test]
    fn test_config_serialization() {
        let mut config = Config::new();
        config.update_source = "https://example.com/updates".to_string();

        let tmp_dir = tempdir().unwrap();
        let config_path = tmp_dir.path().join("config.ron");

        config.save_to_path(&config_path).unwrap();

        let loaded_config = Config::load_from_path(&config_path).unwrap();
        assert_eq!(loaded_config.update_source, "https://example.com/updates");
    }

    #[test]
    fn test_config_not_found() {
        let tmp_dir = tempdir().unwrap();
        let non_existent_path = tmp_dir.path().join("nonexistent.ron");

        let result = Config::load_from_path(&non_existent_path);
        assert!(matches!(result, Err(ConfigError::NotFound(_))));
    }
}
############### ENDOFFILE ########################

############### db.rs #########################
//! # Package Database (`PackageDB`)
//!
//! This module provides an abstraction layer over an SQLite database used
//! by **UHPM (Universal Home Package Manager)** to track installed packages,
//! their versions, installed files, and dependencies.
//!
//! ## Responsibilities
//! - Initialize and maintain the SQLite database schema.
//! - Add, update, and remove package records.
//! - Track installed files and dependencies.
//! - Query package information, including versions and current package state.
//!
//! ## Tables
//! - **`packages`**
//!   - Stores package metadata (name, version, author, source, checksum).
//!   - Marks which version is currently active via the `current` column.
//!
//! - **`installed_files`**
//!   - Maps installed package files to their owning package.
//!
//! - **`dependencies`**
//!   - Tracks package dependencies by name and version.
//!
//! ## Example
//! ```rust,no_run
//! use uhpm::db::PackageDB;
//! use std::path::Path;
//!
//! # tokio_test::block_on(async {
//! let db = PackageDB::new(Path::new("/tmp/uhpm.db"))
//!     .unwrap()
//!     .init()
//!     .await
//!     .unwrap();
//!
//! let packages = db.list_packages().await.unwrap();
//! println!("Installed packages: {:?}", packages);
//! # });
//! ```

use crate::package::{Package, Source};
use crate::{debug, info};
use semver::Version;
use sqlx::Row;
use sqlx::SqlitePool;
use std::fs;
use std::path::{Path, PathBuf};

/// Represents the UHPM package database.
///
/// Internally, this is an SQLite database stored on disk,
/// providing structured access to package metadata.
pub struct PackageDB {
    pool: SqlitePool,
    path: PathBuf,
}

impl PackageDB {
    /// Creates a new `PackageDB` instance and ensures the database file exists.
    ///
    /// This does **not** establish a connection yet.
    ///
    /// # Arguments
    /// - `path`: Path to the SQLite database file.
    ///
    /// # Errors
    /// Returns [`std::io::Error`] if the file or directories cannot be created.
    pub fn new(path: &Path) -> Result<Self, std::io::Error> {
        debug!("db.new.creating", path);

        if !path.exists() {
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent)?;
            }
            std::fs::File::create(path)?;
            debug!("db.new.file_created", path);
        }

        // Placeholder pool, replaced later in `init`
        Ok(PackageDB {
            pool: SqlitePool::connect_lazy("sqlite::memory:")
                .expect("lazy pool must work for placeholder"),
            path: path.to_path_buf(),
        })
    }

    /// Establishes a real database connection and initializes tables if needed.
    ///
    /// # Errors
    /// Returns [`sqlx::Error`] if the database connection or table creation fails.
    pub async fn init(mut self) -> Result<Self, sqlx::Error> {
        let path_str = self.path.to_str().expect("Invalid UTF-8 path");
        let db_url = format!("sqlite://{}", path_str);
        debug!("db.init.connecting", &db_url);

        self.pool = SqlitePool::connect(&db_url).await?;

        debug!("db.init.ensuring_tables");
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS packages (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                version TEXT NOT NULL,
                author TEXT NOT NULL,
                src TEXT NOT NULL,
                checksum TEXT NOT NULL,
                current BOOLEAN NOT NULL DEFAULT 0
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS installed_files (
                package_name TEXT NOT NULL,
                file_path TEXT NOT NULL,
                PRIMARY KEY(package_name, file_path)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS dependencies (
                package_name TEXT NOT NULL,
                dependency_name TEXT NOT NULL,
                dependency_version TEXT NOT NULL,
                PRIMARY KEY(package_name, dependency_name)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        info!("db.init.success", &self.path);
        Ok(self)
    }

    /// Returns a reference to the connection pool.
    pub fn pool(&self) -> &SqlitePool {
        &self.pool
    }

    /// Adds or replaces a package entry in the database (without files or dependencies).
    pub async fn add_package(&self, pkg: &Package) -> Result<(), sqlx::Error> {
        debug!("db.add_package.adding", pkg.name(), pkg.version());
        sqlx::query(
            "INSERT OR REPLACE INTO packages (name, version, author, src, checksum, current) VALUES (?, ?, ?, ?, ?, 0)"
        )
        .bind(&pkg.name())
        .bind(&pkg.version().to_string())
        .bind(&pkg.author())
        .bind(&pkg.src().as_str())
        .bind(&pkg.checksum())
        .execute(&self.pool)
        .await?;
        debug!("db.add_package.added", pkg.name());
        Ok(())
    }

    /// Adds a package with its dependencies and installed files.
    pub async fn add_package_full(
        &self,
        pkg: &Package,
        installed_files: &[String],
    ) -> Result<(), sqlx::Error> {
        info!(
            "db.add_package_full.adding",
            pkg.name(),
            pkg.version(),
            installed_files.len()
        );

        self.add_package(pkg).await?;

        // Dependencies
        for (dep_name, dep_version) in pkg.dependencies() {
            debug!(
                "db.add_package_full.adding_dependency",
                &dep_name, &dep_version
            );
            sqlx::query(
                "INSERT OR REPLACE INTO dependencies (package_name, dependency_name, dependency_version) VALUES (?, ?, ?)"
            )
            .bind(&pkg.name())
            .bind(dep_name)
            .bind(&dep_version.to_string())
            .execute(&self.pool)
            .await?;
        }

        // Installed files
        for file_path in installed_files {
            debug!("db.add_package_full.adding_file", file_path);
            sqlx::query(
                "INSERT OR REPLACE INTO installed_files (package_name, file_path) VALUES (?, ?)",
            )
            .bind(&pkg.name())
            .bind(file_path)
            .execute(&self.pool)
            .await?;
        }

        info!("db.add_package_full.success", pkg.name());
        Ok(())
    }

    /// Returns all files installed by a package.
    pub async fn get_installed_files(&self, pkg_name: &str) -> Result<Vec<String>, sqlx::Error> {
        debug!("db.get_installed_files.fetching", pkg_name);
        let rows = sqlx::query("SELECT file_path FROM installed_files WHERE package_name = ?")
            .bind(pkg_name)
            .fetch_all(&self.pool)
            .await?;

        let files: Vec<String> = rows
            .into_iter()
            .map(|row| row.get::<String, _>("file_path"))
            .collect();
        debug!("db.get_installed_files.found", files.len(), pkg_name);
        Ok(files)
    }

    /// Removes a package and its associated data from the database.
    pub async fn remove_package(&self, pkg_name: &str) -> Result<(), sqlx::Error> {
        info!("db.remove_package.removing", pkg_name);
        sqlx::query("DELETE FROM installed_files WHERE package_name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;
        sqlx::query("DELETE FROM dependencies WHERE package_name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;
        sqlx::query("DELETE FROM packages WHERE name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;
        info!("db.remove_package.removed", pkg_name);
        Ok(())
    }

    /// Returns the current version of a package, if installed.
    pub async fn get_package_version(&self, pkg_name: &str) -> Result<Option<String>, sqlx::Error> {
        debug!("db.get_package_version.fetching", pkg_name);
        let row = sqlx::query("SELECT version FROM packages WHERE name = ? AND current = 1")
            .bind(pkg_name)
            .fetch_optional(&self.pool)
            .await?;
        let result = row.map(|r| r.get::<String, _>("version"));
        debug!("db.get_package_version.result", pkg_name, &result);
        Ok(result)
    }

    pub async fn get_latest_package_version(
        &self,
        pkg_name: &str,
    ) -> Result<Option<Package>, sqlx::Error> {
        debug!("db.get_latest_package_version.fetching", pkg_name);

        // Get all packages with the given name
        let rows =
            sqlx::query("SELECT name, version, author, src, checksum FROM packages WHERE name = ?")
                .bind(pkg_name)
                .fetch_all(&self.pool)
                .await?;

        if rows.is_empty() {
            debug!("db.get_latest_package_version.not_found", pkg_name);
            return Ok(None);
        }

        // Parse packages and find the one with maximum version
        let mut packages = Vec::new();

        for row in rows {
            let version_str: String = row.get("version");
            if let Ok(version) = Version::parse(&version_str) {
                packages.push((row, version));
            } else {
                debug!(
                    "db.get_latest_package_version.invalid_version",
                    pkg_name, &version_str
                );
            }
        }

        if packages.is_empty() {
            debug!("db.get_latest_package_version.no_valid_versions", pkg_name);
            return Ok(None);
        }

        // Find the package with maximum version
        let (latest_row, latest_version) = packages
            .into_iter()
            .max_by(|(_, a), (_, b)| a.cmp(b))
            .expect("packages is not empty");

        debug!(
            "db.get_latest_package_version.found",
            pkg_name, &latest_version
        );

        let package = Package::new(
            latest_row.get::<String, _>("name"),
            latest_version,
            latest_row.get::<String, _>("author"),
            Source::Raw(latest_row.get::<String, _>("src")),
            latest_row.get::<String, _>("checksum"),
            Vec::new(), // Empty dependencies for now
        );

        debug!("db.get_latest_package_version.retrieved", &package);
        Ok(Some(package))
    }

    /// Lists all installed packages.
    pub async fn list_packages(&self) -> Result<Vec<(String, String, bool)>, sqlx::Error> {
        debug!("db.list_packages.listing");
        let rows = sqlx::query("SELECT name, version, current FROM packages")
            .fetch_all(&self.pool)
            .await?;

        let mut packages = Vec::new();
        for row in rows {
            let name: String = row.get("name");
            let version: String = row.get("version");
            let current: bool = row.get("current");
            debug!("db.list_packages.found", &name, &version, current);
            packages.push((name, version, current));
        }

        Ok(packages)
    }

    /// Checks if a package is installed and returns its latest version.
    pub async fn is_installed(&self, name: &str) -> Result<Option<Version>, sqlx::Error> {
        debug!("db.is_installed.checking", name);
        let row = sqlx::query(
            "SELECT version FROM packages WHERE name = ? ORDER BY version DESC LIMIT 1",
        )
        .bind(name)
        .fetch_optional(&self.pool)
        .await?;

        if let Some(r) = row {
            let ver_str: String = r.get("version");
            let ver = Version::parse(&ver_str).unwrap_or_else(|_| Version::new(0, 0, 0));
            debug!("db.is_installed.latest_version", name, &ver);
            Ok(Some(ver))
        } else {
            debug!("db.is_installed.not_found", name);
            Ok(None)
        }
    }

    /// Retrieves the current package metadata, including dependencies.
    pub async fn get_current_package(
        &self,
        pkg_name: &str,
    ) -> Result<Option<Package>, sqlx::Error> {
        debug!("db.get_current_package.fetching", pkg_name);
        let row = sqlx::query(
            "SELECT name, version, author, src, checksum FROM packages WHERE name = ? LIMIT 1",
        )
        .bind(pkg_name)
        .fetch_optional(&self.pool)
        .await?;

        let row = match row {
            Some(r) => r,
            None => {
                debug!("db.get_current_package.not_found", pkg_name);
                return Ok(None);
            }
        };

        // Dependencies
        let dep_rows = sqlx::query(
            "SELECT dependency_name, dependency_version FROM dependencies WHERE package_name = ?",
        )
        .bind(pkg_name)
        .fetch_all(&self.pool)
        .await?;

        let mut dependencies = Vec::new();
        for dep in dep_rows {
            let dep_name: String = dep.get("dependency_name");
            let dep_version_str: String = dep.get("dependency_version");
            if let Ok(dep_version) = Version::parse(&dep_version_str) {
                dependencies.push((dep_name, dep_version));
            }
        }

        let package = Package::new(
            row.get::<String, _>("name"),
            Version::parse(&row.get::<String, _>("version"))
                .unwrap_or_else(|_| Version::new(0, 0, 0)),
            row.get::<String, _>("author"),
            Source::Raw(row.get::<String, _>("src")),
            row.get::<String, _>("checksum"),
            dependencies,
        );

        debug!("db.get_current_package.retrieved", &package);
        Ok(Some(package))
    }

    /// Sets a specific version of a package as the current version.
    pub async fn set_current_version(
        &self,
        pkg_name: &str,
        version: &str,
    ) -> Result<(), sqlx::Error> {
        info!("db.set_current_version.setting", version, pkg_name);
        sqlx::query("UPDATE packages SET current = 0 WHERE name = ?")
            .bind(pkg_name)
            .execute(&self.pool)
            .await?;

        sqlx::query("UPDATE packages SET current = 1 WHERE name = ? AND version = ?")
            .bind(pkg_name)
            .bind(version)
            .execute(&self.pool)
            .await?;

        info!("db.set_current_version.success", version, pkg_name);
        Ok(())
    }

    /// Retrieves a specific version of a package by name and version string.
    pub async fn get_package_by_version(
        &self,
        pkg_name: &str,
        pkg_version: &str,
    ) -> Result<Option<Package>, sqlx::Error> {
        debug!("db.get_package_by_version.fetching", pkg_name, pkg_version);
        let row = sqlx::query(
            "SELECT name, version, author, src, checksum
             FROM packages
             WHERE name = ? AND version = ? LIMIT 1",
        )
        .bind(pkg_name)
        .bind(pkg_version)
        .fetch_optional(&self.pool)
        .await?;

        let row = match row {
            Some(r) => r,
            None => {
                debug!("db.get_package_by_version.not_found", pkg_name, pkg_version);
                return Ok(None);
            }
        };

        // Dependencies
        let dep_rows = sqlx::query(
            "SELECT dependency_name, dependency_version
             FROM dependencies
             WHERE package_name = ?",
        )
        .bind(pkg_name)
        .fetch_all(&self.pool)
        .await?;

        let mut dependencies = Vec::new();
        for dep in dep_rows {
            let dep_name: String = dep.get("dependency_name");
            let dep_version_str: String = dep.get("dependency_version");
            if let Ok(dep_version) = Version::parse(&dep_version_str) {
                dependencies.push((dep_name, dep_version));
            }
        }

        let package = Package::new(
            row.get::<String, _>("name"),
            Version::parse(&row.get::<String, _>("version"))
                .unwrap_or_else(|_| Version::new(0, 0, 0)),
            row.get::<String, _>("author"),
            Source::Raw(row.get::<String, _>("src")),
            row.get::<String, _>("checksum"),
            dependencies,
        );

        debug!("db.get_package_by_version.retrieved", &package);
        Ok(Some(package))
    }
}
############### ENDOFFILE ########################

############### error.rs #########################
use ron::error::SpannedError;
use semver::Version;
use std::path::PathBuf;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum SwitchError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("Package directory not found: {0}")]
    MissingPackageDir(PathBuf),
    #[error("Symlist error: {0}")]
    Symlist(#[from] crate::symlist::SymlistError),
    #[error("Package not found: {0} version {1}")]
    PackageNotFound(String, Version),
}

#[derive(Error, Debug)]
pub enum UpdaterError {
    #[error("Package not found: {0}")]
    NotFound(String),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Repository error: {0}")]
    Repo(#[from] RepoError),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("Fetch error: {0}")]
    Fetch(#[from] FetchError),
    #[error("No newer version available for package: {0}")]
    NoNewVersion(String),
}

#[derive(Error, Debug)]
pub enum UhpmError {
    #[error("Configuration error: {0}")]
    Config(#[from] ConfigError),
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    #[error("Repository error: {0}")]
    Repository(#[from] RepoError),
    #[error("Package error: {0}")]
    Package(String),
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Parse error: {0}")]
    Parse(String),
    #[error("Package not found: {0}")]
    NotFound(String),
    #[error("No newer version available for package: {0}")]
    NoNewVersion(String),
    #[error("Validation error: {0}")]
    Validation(String),
}

#[derive(Error, Debug)]
pub enum RemoveError {
    #[error("Package not found: {0}")]
    NotFound(String),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("RON parse error: {0}")]
    Ron(#[from] SpannedError),
    #[error("Configuration file not found: {0}")]
    NotFound(String),
}

#[derive(Error, Debug)]
pub enum RepoError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("Package not found: {0}")]
    NotFound(String),
}

#[derive(Error, Debug)]
pub enum FetchError {
    #[error("HTTP error: {0}")]
    Http(#[from] reqwest::Error),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Installer error: {0}")]
    Installer(String),
}

#[derive(Error, Debug)]
pub enum MetaParseError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("RON parse error: {0}")]
    Ron(#[from] SpannedError),
}

impl From<SwitchError> for UhpmError {
    fn from(error: SwitchError) -> Self {
        match error {
            SwitchError::Io(e) => UhpmError::Io(e),
            SwitchError::Db(e) => UhpmError::Database(e),
            SwitchError::MissingPackageDir(path) => {
                UhpmError::NotFound(format!("Package directory not found: {}", path.display()))
            }
            SwitchError::Symlist(e) => UhpmError::Parse(e.to_string()),
            SwitchError::PackageNotFound(name, version) => {
                UhpmError::NotFound(format!("Package {} version {} not found", name, version))
            }
        }
    }
}

impl From<UpdaterError> for UhpmError {
    fn from(error: UpdaterError) -> Self {
        match error {
            UpdaterError::NotFound(name) => UhpmError::NotFound(name),
            UpdaterError::Io(e) => UhpmError::Io(e),
            UpdaterError::Repo(e) => UhpmError::Repository(e),
            UpdaterError::Db(e) => UhpmError::Database(e),
            UpdaterError::Fetch(e) => UhpmError::from(e),
            UpdaterError::NoNewVersion(name) => UhpmError::NoNewVersion(name),
        }
    }
}

impl From<FetchError> for UhpmError {
    fn from(error: FetchError) -> Self {
        match error {
            FetchError::Http(e) => UhpmError::Network(e),
            FetchError::Io(e) => UhpmError::Io(e),
            FetchError::Installer(msg) => UhpmError::Package(msg),
        }
    }
}

impl From<MetaParseError> for UhpmError {
    fn from(error: MetaParseError) -> Self {
        match error {
            MetaParseError::Io(e) => UhpmError::Io(e),
            MetaParseError::Ron(e) => UhpmError::Parse(e.to_string()),
        }
    }
}

impl From<RemoveError> for UhpmError {
    fn from(error: RemoveError) -> Self {
        match error {
            RemoveError::NotFound(name) => UhpmError::NotFound(name),
            RemoveError::Db(e) => UhpmError::Database(e),
            RemoveError::Io(e) => UhpmError::Io(e),
        }
    }
}

impl From<String> for UhpmError {
    fn from(error: String) -> Self {
        UhpmError::Package(error)
    }
}

impl From<&str> for ConfigError {
    fn from(s: &str) -> Self {
        ConfigError::NotFound(s.to_string())
    }
}
############### ENDOFFILE ########################

############### fetcher.rs #########################
//! # Package Fetcher
//!
//! This module handles downloading packages from URLs (HTTP or local `file://` paths)
//! and installing them into UHPM.
//!
//! ## Responsibilities
//! - Download `.uhp` package archives from repositories or local paths.
//! - Provide progress bars for concurrent downloads.
//! - Integrate with the [`installer`](crate::package::installer) to complete installation.
//!
//! ## Features
//! - Supports both **HTTP(S)** and **file://** sources.
//! - Parallel downloading using [`FuturesUnordered`].
//! - Progress display via [`indicatif`].
//! - Error handling through [`FetchError`].
//!
//! ## Example
//! ```rust,no_run
//! use uhpm::db::PackageDB;
//! use uhpm::fetcher::fetch_and_install_parallel;
//! # use std::path::Path;
//!
//! # tokio_test::block_on(async {
//! let db = PackageDB::new(Path::new("/tmp/uhpm.db"))
//!     .unwrap()
//!     .init()
//!     .await
//!     .unwrap();
//!
//! let urls = vec![
//!     "https://example.com/package.uhp".to_string(),
//!     "file:///home/user/package.uhp".to_string()
//! ];
//!
//! fetch_and_install_parallel(&urls, &db).await.unwrap();
//! # });
//! ```

use crate::db::PackageDB;
use crate::error::FetchError;
use crate::package::installer;
use crate::{error, info};
use futures::stream::{FuturesUnordered, StreamExt};
use indicatif::{ProgressBar, ProgressStyle};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use tokio::fs;

/// Errors that can occur during package fetching and installation.

/// Downloads a single package from the given URL.
///
/// - Supports both `http(s)://` and `file://` schemes.
/// - For local `file://` paths, simply converts to [`PathBuf`].
/// - For remote URLs, saves the response to the temporary directory.
///
/// # Errors
/// Returns a [`FetchError`] if the request or file writing fails.
async fn download_package(url: &str) -> Result<PathBuf, FetchError> {
    if let Some(stripped) = url.strip_prefix("file://") {
        Ok(PathBuf::from(stripped))
    } else {
        let resp = reqwest::get(url).await?.bytes().await?;
        let tmp_dir = std::env::temp_dir();
        let filename = Path::new(url)
            .file_name()
            .and_then(|f| f.to_str())
            .ok_or_else(|| {
                FetchError::Io(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    "Unable to determine filename from URL",
                ))
            })?;
        let tmp_path = tmp_dir.join(filename);
        fs::write(&tmp_path, &resp).await?;
        Ok(tmp_path)
    }
}

/// Downloads multiple packages concurrently.
///
/// Shows a progress bar using [`indicatif`] while downloading.
/// Returns a map of successfully downloaded URLs to local file paths.
pub async fn fetch_packages(urls: &[String]) -> HashMap<String, PathBuf> {
    let bar = ProgressBar::new(urls.len() as u64);
    bar.set_style(
        ProgressStyle::default_bar()
            .template("[{bar:40.cyan/blue}] {pos}/{len} {msg}")
            .unwrap()
            .progress_chars("##-"),
    );

    let mut futures = FuturesUnordered::new();
    for url in urls {
        let url_clone = url.clone();
        futures.push(async move {
            let path = download_package(&url_clone).await;
            (url_clone, path)
        });
    }

    let mut results = HashMap::new();
    while let Some((url, res)) = futures.next().await {
        match res {
            Ok(path) => {
                results.insert(url.clone(), path);
                bar.inc(1);
                bar.set_message(format!("Downloaded: {}", url));
            }
            Err(e) => {
                error!("fetcher.download.failed", url, e);
                bar.inc(1);
            }
        }
    }
    bar.finish_with_message("Download complete");
    results
}

/// Installs already downloaded packages into the database.
///
/// # Errors
/// Returns [`FetchError::Installer] if the installation fails.
pub async fn install_fetched_packages(
    packages: &HashMap<String, PathBuf>,
    package_db: &PackageDB,
) -> Result<(), FetchError> {
    for (url, path) in packages {
        info!("fetcher.install.from_url", url);
        installer::install(path, package_db).await.map_err(|e| {
            FetchError::Installer(format!("Installation failed for {}: {:?}", url, e))
        })?;
    }
    Ok(())
}

/// Downloads and installs packages in parallel.
///
/// - Downloads all URLs concurrently.
/// - Installs them sequentially after downloading.
///
/// # Errors
/// Returns [`FetchError`] if downloading or installation fails.
pub async fn fetch_and_install_parallel(
    urls: &[String],
    package_db: &PackageDB,
) -> Result<(), FetchError> {
    let downloaded = fetch_packages(urls).await;
    install_fetched_packages(&downloaded, package_db).await?;
    Ok(())
}
############### ENDOFFILE ########################

############### lib.rs #########################
pub mod cli;
pub mod config;
pub mod db;
pub mod error;
pub mod fetcher;
pub mod locale;
pub mod log;
pub mod package;
pub mod repo;
pub mod self_remove;
pub mod service;
pub mod symlist;

use std::fs;

pub fn clear_tmp() -> std::io::Result<()> {
    let mut tmp_dir = dirs::home_dir().unwrap();
    tmp_dir.push(".uhpm/tmp");

    if tmp_dir.exists() {
        fs::remove_dir_all(&tmp_dir)?;
        fs::create_dir_all(&tmp_dir)?;
    }

    Ok(())
}
############### ENDOFFILE ########################

############### locale.rs #########################
//! locale.rs
//!
//! Provides localization support for UHPM.
//! Features:
//! - Automatic detection of system locale
//! - Loading translations from `locale/<lang>.ron`
//! - Retrieving localized messages

use std::{collections::HashMap, fs, path::Path};
use sys_locale::get_locale;
use tracing::warn;

/// Main struct for localization
#[derive(Debug)]
pub struct Locale {
    /// Active language code, e.g., "en", "ru"
    pub lang: String,
    /// Loaded localized messages
    pub messages: HashMap<String, String>,
}

impl Locale {
    /// Initializes a Locale instance
    /// - Detects system locale
    /// - Loads the corresponding translation file from `locale/<lang>.ron`
    pub fn initialize() -> Self {
        let lang_full = get_locale().unwrap_or_else(|| "en".to_string());
        let lang = lang_full.chars().take(2).collect::<String>();
        let messages = Self::load_messages(&lang).unwrap_or_else(|err| {
            warn!("Failed to load locale '{}': {}", lang, err);
            HashMap::new()
        });

        Self { lang, messages }
    }

    /// Loads messages from RON file and flattens the structure
    fn load_messages(lang: &str) -> Result<HashMap<String, String>, Box<dyn std::error::Error>> {
        #[cfg(debug_assertions)]
        let path = Path::new("locale").join(format!("{}.ron", lang));

        #[cfg(not(debug_assertions))]
        let path = dirs::home_dir()
            .unwrap()
            .join(".uhpm")
            .join("locale")
            .join(format!("{}.ron", lang));

        if !path.exists() {
            return Err(format!("Locale file not found: {:?}", path).into());
        }

        let content = fs::read_to_string(&path)?;

        // Parse RON into Value
        let value: ron::Value = ron::from_str(&content)?;

        // Recursively collect all strings into a flat HashMap
        let mut messages = HashMap::new();
        Self::flatten_value(value, &mut messages, String::new());

        Ok(messages)
    }

    /// Recursively traverses RON structure and collects all strings
    fn flatten_value(
        value: ron::Value,
        messages: &mut HashMap<String, String>,
        current_key: String,
    ) {
        match value {
            ron::Value::Map(map) => {
                for (key, value) in map.into_iter() {
                    // Only string keys are processed
                    if let ron::Value::String(key_str) = key {
                        let new_key = if current_key.is_empty() {
                            key_str
                        } else {
                            format!("{}.{}", current_key, key_str)
                        };
                        Self::flatten_value(value, messages, new_key);
                    }
                    // Other key types are ignored
                }
            }
            ron::Value::String(s) => {
                messages.insert(current_key, s);
            }
            _ => {} // Ignore numbers, booleans, etc. - only strings matter
        }
    }

    /// Retrieves a localized message by key
    /// Falls back to the key itself if translation is missing
    pub fn msg(&self, key: &str) -> String {
        self.messages
            .get(key)
            .cloned()
            .unwrap_or_else(|| key.to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_subscriber;

    #[test]
    fn test_locale_load() {
        tracing_subscriber::fmt::init();

        let locale = Locale::initialize();
        println!("Active locale: {}", locale.lang);

        let msg = locale.msg("main.info.uhpm_started");
        println!("Localized message: {}", msg);

        assert!(locale.lang.len() == 2 || locale.lang.len() == 1);
    }
}
############### ENDOFFILE ########################

############### log.rs #########################
//! log.rs
//!
//! Localized logging with auto-detected system locale.
//! Provides macros: info!(), warn!(), debug!(), error!(), lprintln!(), lprint!().
//! Supports multiple arguments of any type and substitutes them in order.

use crate::locale::Locale;
use once_cell::sync::Lazy;

/// Global static logger
pub static LOGGER: Lazy<Locale> = Lazy::new(|| Locale::initialize());

/// Helper: replaces `{}` placeholders in template with provided arguments
pub fn format_ordered(template: &str, args: &[String]) -> String {
    let mut result = String::new();
    let mut parts = template.split("{}");
    let mut iter = args.iter();

    if let Some(first) = parts.next() {
        result.push_str(first);
    }

    for part in parts {
        if let Some(arg) = iter.next() {
            result.push_str(arg);
        }
        result.push_str(part);
    }

    result
}

/// Internal helper to format any type with Debug
pub fn fmt_debug<T: std::fmt::Debug>(val: T) -> String {
    format!("{:?}", val)
}

// -------------------- MACROS -------------------- //

#[macro_export]
macro_rules! info {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::info!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! warn {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::warn!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! debug {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::debug!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! error {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            tracing::error!(target: "uhpm", "{}", msg);
        }
    };
}

#[macro_export]
macro_rules! lprintln {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            println!("{}", msg);
        }
    };
}

#[macro_export]
macro_rules! lprint {
    ($key:expr $(, $arg:expr)*) => {
        {
            let template = $crate::log::LOGGER.msg($key);
            let args: Vec<String> = vec![$($crate::log::fmt_debug($arg)),*];
            let msg = $crate::log::format_ordered(&template, &args);
            print!("{}", msg);
        }
    };
}
############### ENDOFFILE ########################

############### package.rs #########################
//! # Package Module

use crate::error::MetaParseError;
use semver::Version;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
pub mod installer;
pub mod remover;
pub mod switcher;
pub mod updater;

/// Represents the source of a package.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", content = "value")]
pub enum Source {
    Url(String),
    LocalPath(String),
    Raw(String),
}

impl Source {
    pub fn as_str(&self) -> &str {
        match self {
            Source::Url(s) | Source::Raw(s) => s,
            Source::LocalPath(p) => p,
        }
    }
}

/// Represents a dependency with name and version
#[derive(Serialize, Deserialize, Debug)]
pub struct Dependency {
    pub name: String,
    pub version: Version,
}

/// Represents a UHPM package with its metadata and dependencies.
#[derive(Serialize, Deserialize, Debug)]
pub struct Package {
    name: String,
    author: String,
    version: Version,
    src: Source,
    checksum: String,
    #[serde(default)]
    dependencies: Vec<Dependency>,
}

impl Package {
    pub fn new(
        name: impl Into<String>,
        version: Version,
        author: impl Into<String>,
        src: Source,
        checksum: impl Into<String>,
        dependencies: Vec<(String, Version)>,
    ) -> Self {
        let deps = dependencies
            .into_iter()
            .map(|(name, version)| Dependency { name, version })
            .collect();

        Self {
            name: name.into(),
            version,
            author: author.into(),
            src,
            checksum: checksum.into(),
            dependencies: deps,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn author(&self) -> &str {
        &self.author
    }

    pub fn version(&self) -> &Version {
        &self.version
    }

    pub fn src(&self) -> &Source {
        &self.src
    }

    pub fn checksum(&self) -> &str {
        &self.checksum
    }

    pub fn dependencies(&self) -> Vec<(String, Version)> {
        self.dependencies
            .iter()
            .map(|dep| (dep.name.clone(), dep.version.clone()))
            .collect()
    }

    pub fn from_toml_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let data = fs::read_to_string(path)?;
        let pkg: Package = toml::from_str(&data)?;
        Ok(pkg)
    }

    pub fn template() -> Self {
        Package {
            name: "my_package".to_string(),
            author: "YourName".to_string(),
            version: Version::parse("0.1.0").unwrap(),
            src: Source::Raw("TODO".to_string()),
            checksum: "TODO".to_string(),
            dependencies: vec![],
        }
    }

    pub fn save_to_toml(&self, path: &std::path::Path) -> Result<(), Box<dyn std::error::Error>> {
        let toml_str = toml::to_string_pretty(self)?;
        std::fs::write(path, toml_str)?;
        Ok(())
    }
}

pub fn meta_parser(meta_path: &Path) -> Result<Package, MetaParseError> {
    let data = fs::read_to_string(meta_path)?;
    let pkg: Package = toml::from_str(&data).map_err(|e| {
        MetaParseError::Io(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("TOML parse error: {}", e),
        ))
    })?;
    Ok(pkg)
}

pub fn get_pkg_path(pkg_name: &str, pkg_ver: Version) -> PathBuf {
    let packages_path: PathBuf = dirs::home_dir().unwrap().join(".uhpm").join("packages");
    packages_path.join(format!("{}-{}", pkg_name, pkg_ver.to_string()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use semver::Version;
    use std::fs;

    fn sample_package_toml() -> String {
        r#"
name = "test_pkg"
author = "Tester"
version = "0.1.0"
checksum = "abc123"

[src]
type = "Raw"
value = "some content"

[[dependencies]]
name = "dep_pkg"
version = "1.0.0"
"#
        .to_string()
    }

    #[test]
    fn test_from_toml_file() {
        let tmp_dir = tempfile::tempdir().unwrap();
        let toml_path = tmp_dir.path().join("uhp.toml");
        fs::write(&toml_path, sample_package_toml()).unwrap();

        let pkg = Package::from_toml_file(&toml_path).unwrap();
        assert_eq!(pkg.name(), "test_pkg");
        assert_eq!(pkg.author(), "Tester");
        assert_eq!(pkg.version(), &Version::parse("0.1.0").unwrap());
        assert_eq!(pkg.src().as_str(), "some content");
        assert_eq!(pkg.checksum(), "abc123");
        assert_eq!(pkg.dependencies().len(), 1);
        assert_eq!(pkg.dependencies()[0].0, "dep_pkg");
        assert_eq!(pkg.dependencies()[0].1, Version::parse("1.0.0").unwrap());
    }

    #[test]
    fn test_meta_parser() {
        let tmp_dir = tempfile::tempdir().unwrap();
        let toml_path = tmp_dir.path().join("uhp.toml");
        fs::write(&toml_path, sample_package_toml()).unwrap();

        let pkg = meta_parser(&toml_path).unwrap();
        assert_eq!(pkg.name(), "test_pkg");
        assert_eq!(pkg.author(), "Tester");
    }

    #[test]
    fn test_save_and_load_toml() {
        let tmp_dir = tempfile::tempdir().unwrap();
        let toml_path = tmp_dir.path().join("test_pkg.toml");

        let original_pkg = Package::new(
            "test_package",
            Version::parse("1.2.3").unwrap(),
            "Test Author",
            Source::Url("https://example.com/pkg.uhp".to_string()),
            "sha256:abc123",
            vec![
                ("dep1".to_string(), Version::parse("1.0.0").unwrap()),
                ("dep2".to_string(), Version::parse("2.0.0").unwrap()),
            ],
        );

        original_pkg.save_to_toml(&toml_path).unwrap();

        // Проверим, что сохранилось правильно
        let saved_content = fs::read_to_string(&toml_path).unwrap();
        println!("Saved TOML:\n{}", saved_content);

        let loaded_pkg = Package::from_toml_file(&toml_path).unwrap();

        assert_eq!(original_pkg.name(), loaded_pkg.name());
        assert_eq!(original_pkg.author(), loaded_pkg.author());
        assert_eq!(original_pkg.version(), loaded_pkg.version());
        assert_eq!(original_pkg.checksum(), loaded_pkg.checksum());
        assert_eq!(
            original_pkg.dependencies().len(),
            loaded_pkg.dependencies().len()
        );
    }

    #[test]
    fn test_source_serialization() {
        let pkg = Package::new(
            "test",
            Version::parse("1.0.0").unwrap(),
            "author",
            Source::Raw("content".to_string()),
            "checksum",
            vec![],
        );

        let toml_str = toml::to_string_pretty(&pkg).unwrap();
        println!("Serialized package:\n{}", toml_str);

        // Проверим, что можем десериализовать обратно
        let deserialized: Package = toml::from_str(&toml_str).unwrap();
        assert_eq!(pkg.name(), deserialized.name());
    }
}
############### ENDOFFILE ########################

############### repo.rs #########################
//! # Repository Module
//!
//! This module defines [`RepoDB`] and related utilities for managing package
//! repositories in **UHPM (Universal Home Package Manager)**.
//!
//! ## Responsibilities
//! - Store metadata about available packages in a repository (SQLite).
//! - Provide URLs for downloading package archives.
//! - Parse repository configuration files (`repos.ron`).
//!
//! ## Tables
//! - **`packages`**
//!   - Stores basic package metadata: `name`, `version`, `author`, `src`, `checksum`.
//! - **`urls`**
//!   - Maps `(name, version)` pairs to download URLs.
//!
//! ## Example
//! ```rust,no_run
//! use uhpm::repo::RepoDB;
//! use std::path::Path;
//!
//! # tokio_test::block_on(async {
//! let repo_db = RepoDB::new(Path::new("/tmp/repo.db")).await.unwrap();
//!
//! // Add a package
//! repo_db.add_package("foo", "1.0.0", "Alice", "src", "sha256").await.unwrap();
//! repo_db.add_url("foo", "1.0.0", "https://example.com/foo-1.0.0.uhp").await.unwrap();
//!
//! // List packages
//! let pkgs = repo_db.list_packages().await.unwrap();
//! println!("{:?}", pkgs);
//! # });
//! ```

use crate::error::RepoError;
use ron::from_str;
use sqlx::{Row, SqlitePool};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Errors that may occur while working with repositories.

/// SQLite-backed package repository database.
///
/// Used for storing available package metadata and their download URLs.
pub struct RepoDB {
    pool: SqlitePool,
}

impl RepoDB {
    pub fn pool(&self) -> &SqlitePool {
        return &self.pool;
    }
    /// Opens (or creates) a new repository database at the given path.
    ///
    /// Ensures required tables exist by calling [`RepoDB::init_tables`].
    pub async fn new(db_path: &Path) -> Result<Self, sqlx::Error> {
        if !db_path.exists() {
            if let Some(parent) = db_path.parent() {
                std::fs::create_dir_all(parent).expect("Failed to create directory for database");
            }
            std::fs::File::create(db_path).expect("Cannot create database file");
        }

        let db_url = format!("sqlite://{}", db_path.to_str().unwrap());
        let pool = SqlitePool::connect(&db_url).await?;
        let db = RepoDB { pool };
        db.init_tables().await?;
        Ok(db)
    }

    /// Initializes required tables (`packages`, `urls`) if they don’t exist.
    async fn init_tables(&self) -> Result<(), sqlx::Error> {
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS packages (
                name TEXT NOT NULL,
                version TEXT NOT NULL,
                author TEXT NOT NULL,
                src TEXT NOT NULL,
                checksum TEXT NOT NULL,
                PRIMARY KEY(name, version)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS urls (
                name TEXT NOT NULL,
                version TEXT NOT NULL,
                url TEXT NOT NULL,
                PRIMARY KEY(name, version)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    /// Returns the download URL for a given package name and version.
    ///
    /// # Errors
    /// Returns [`RepoError::NotFound`] if no URL is found.
    pub async fn get_package(&self, name: &str, version: &str) -> Result<String, RepoError> {
        let row = sqlx::query("SELECT url FROM urls WHERE name = ? AND version = ?")
            .bind(name)
            .bind(version)
            .fetch_optional(&self.pool)
            .await?;

        match row {
            Some(r) => Ok(r.get::<String, _>("url")),
            None => Err(RepoError::NotFound(format!("{}-{}", name, version))),
        }
    }

    /// Lists all packages (name and version) available in this repository.
    pub async fn list_packages(&self) -> Result<Vec<(String, String)>, sqlx::Error> {
        let rows = sqlx::query("SELECT name, version FROM packages")
            .fetch_all(&self.pool)
            .await?;

        let packages = rows
            .into_iter()
            .map(|r| (r.get::<String, _>("name"), r.get::<String, _>("version")))
            .collect();

        Ok(packages)
    }

    /// Adds a package record to the repository (metadata only).
    pub async fn add_package(
        &self,
        name: &str,
        version: &str,
        author: &str,
        src: &str,
        checksum: &str,
    ) -> Result<(), sqlx::Error> {
        sqlx::query(
            "INSERT OR IGNORE INTO packages (name, version, author, src, checksum) VALUES (?, ?, ?, ?, ?)"
        )
        .bind(name)
        .bind(version)
        .bind(author)
        .bind(src)
        .bind(checksum)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    /// Adds or replaces a download URL for a package version.
    pub async fn add_url(&self, name: &str, version: &str, url: &str) -> Result<(), sqlx::Error> {
        sqlx::query("INSERT OR REPLACE INTO urls (name, version, url) VALUES (?, ?, ?)")
            .bind(name)
            .bind(version)
            .bind(url)
            .execute(&self.pool)
            .await?;
        Ok(())
    }
}

/// Parses a `.ron` repositories configuration file.
///
/// The file should define a map of repository names to paths/URLs.
/// Example (`repos.ron`):
/// ```ron
/// {
///     "local": "file:///home/user/uhpm-repo",
///     "main": "https://example.com/uhpm-repo"
/// }
/// ```
pub fn parse_repos<P: AsRef<Path>>(path: P) -> Result<HashMap<String, String>, RepoError> {
    let content = fs::read_to_string(path)?;
    let repos: HashMap<String, String> = from_str(&content).unwrap();
    Ok(repos)
}
############### ENDOFFILE ########################

############### self_remove.rs #########################
//! # Self-remove
//!
//! This module provides functionality for **self-removal** of the UHPM binary
//! and its associated configuration directory (`~/.uhpm`).
//!
//! ## How it works
//! 1. Determines the current binary path using [`std::env::current_exe`].
//! 2. Generates a temporary shell script (`uhpm_uninstall.sh`) in the user’s home directory.
//! 3. The script:
//!    - Waits briefly (`sleep 1`) to allow the UHPM process to exit.
//!    - Removes the UHPM binary itself.
//!    - Deletes the `~/.uhpm` configuration directory.
//!    - Prints a confirmation message.
//!    - Removes itself.
//! 4. Executes the script asynchronously via `bash`.
//!
//! ## Notes
//! - Only works on **Unix-like systems** (uses `PermissionsExt` and shell).
//! - On success, UHPM will remove itself and its data, leaving no trace.

use dirs;
use std::env;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::PathBuf;
use std::process::Command;

/// Removes UHPM from the system by deleting:
/// - The current executable binary
/// - The `~/.uhpm` directory
///
/// This is achieved by writing a temporary shell script (`uhpm_uninstall.sh`)
/// in the user’s home directory, marking it as executable, and running it.
/// The script performs cleanup and then deletes itself.
///
/// # Errors
/// - Returns an [`std::io::Error`] if file operations fail.
/// - Returns a generic error if the `$HOME` directory cannot be determined.
///
/// # Example
/// ```no_run
/// use uhpm::self_remove::self_remove;
///
/// fn main() {
///     if let Err(e) = self_remove() {
///         eprintln!("Failed to self-remove: {}", e);
///     }
/// }
/// ```
pub fn self_remove() -> Result<(), Box<dyn std::error::Error>> {
    // Path to current binary
    let exe_path: PathBuf = env::current_exe()?;
    // Path to ~/.uhpm directory
    let home_dir = dirs::home_dir().ok_or("Failed to get HOME directory")?;
    let uhpm_dir = home_dir.join(".uhpm");

    // Temporary uninstall script in $HOME
    let tmp_script = home_dir.join("uhpm_uninstall.sh");
    let script_content = format!(
        r#"#!/bin/bash
# Wait for the process to exit
sleep 1
rm -f "{}"
rm -rf "{}"
echo "UHPM has been removed"
rm -- "$0"
"#,
        exe_path.to_string_lossy(),
        uhpm_dir.to_string_lossy()
    );

    // Write and make script executable
    fs::write(&tmp_script, script_content)?;
    fs::set_permissions(&tmp_script, fs::Permissions::from_mode(0o755))?;

    // Execute uninstall script asynchronously
    Command::new("bash").arg(tmp_script).spawn()?;

    Ok(())
}
############### ENDOFFILE ########################

############### symlist.rs #########################
//! # Symlist
//!
//! This module handles **symbolic link lists** (`symlist`),
//! which describe what files from an installed package should be symlinked
//! into user/system paths.
//!
//! ## Example format (`symlist`)
//! ```text
//! /path/to/package/bin/my_binary $HOME/.local/bin/my_binary
//! /path/to/package/share/applications/app.desktop $XDG_DATA_HOME/applications/app.desktop
//! ```
//!
//! ## Supported variables
//! - `$HOME` — user home directory
//! - `$XDG_DATA_HOME` — user data directory (defaults to `~/.local/share`)
//! - `$XDG_CONFIG_HOME` — user config directory (defaults to `~/.config`)
//! - `$XDG_BIN_HOME` — user bin directory (defaults to `~/.local/bin`)
//!
//! These variables are automatically expanded in target paths.

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use thiserror::Error;

/// Possible errors when working with symlists
#[derive(Debug, Error)]
pub enum SymlistError {
    /// Input/output error
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    /// Symlist parsing error
    #[error("Symlist parse error: {0}")]
    Parse(String),
}

/// Entry in the symlink list
#[derive(Debug)]
pub struct SymlinkEntry {
    /// Relative path inside the package
    pub source: String,
    /// Target path (with variables)
    pub target: String,
}

/// Expands variables (`$HOME`, `$XDG_*`) in paths
fn expand_vars(path: &str) -> PathBuf {
    let mut vars = HashMap::new();

    if let Some(home) = dirs::home_dir() {
        let home_str = home.to_string_lossy().to_string();

        vars.insert("HOME".to_string(), home_str.clone());

        vars.insert(
            "XDG_DATA_HOME".to_string(),
            std::env::var("XDG_DATA_HOME").unwrap_or_else(|_| format!("{}/.local/share", home_str)),
        );
        vars.insert(
            "XDG_CONFIG_HOME".to_string(),
            std::env::var("XDG_CONFIG_HOME").unwrap_or_else(|_| format!("{}/.config", home_str)),
        );
        vars.insert(
            "XDG_BIN_HOME".to_string(),
            std::env::var("XDG_BIN_HOME").unwrap_or_else(|_| format!("{}/.local/bin", home_str)),
        );
    }

    let mut expanded = path.to_string();
    for (key, value) in vars {
        expanded = expanded.replace(&format!("${}", key), &value);
    }

    PathBuf::from(expanded)
}

/// Parses a single line from symlist file
fn parse_symlist_line(line: &str) -> Result<SymlinkEntry, SymlistError> {
    let line = line.trim();

    // Skip empty lines and comments
    if line.is_empty() || line.starts_with('#') {
        return Err(SymlistError::Parse("Empty or comment line".to_string()));
    }

    let parts: Vec<&str> = line.splitn(2, ' ').collect();
    if parts.len() != 2 {
        return Err(SymlistError::Parse(format!(
            "Invalid line format, expected 'source target', got: {}",
            line
        )));
    }

    let source = parts[0].trim().to_string();
    let target = parts[1].trim().to_string();

    if source.is_empty() || target.is_empty() {
        return Err(SymlistError::Parse(
            "Source or target cannot be empty".to_string(),
        ));
    }

    Ok(SymlinkEntry { source, target })
}

/// Saves a symlist template (`symlist`)
///
/// Useful for package initialization or project bootstrapping.
///
/// # Example
/// ```no_run
/// use uhpm::symlist::save_template;
/// use std::path::Path;
///
/// save_template(Path::new("symlist")).unwrap();
/// ```
pub fn save_template(path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let symlist_template = r#"# Symlink list for package
# Format: <source_path> <target_path_with_variables>
#
# Available variables:
#   $HOME - user home directory
#   $XDG_DATA_HOME - user data directory (~/.local/share)
#   $XDG_CONFIG_HOME - user config directory (~/.config)
#   $XDG_BIN_HOME - user bin directory (~/.local/bin)

bin/my_binary $HOME/.local/bin/my_binary
share/applications/my_app.desktop $XDG_DATA_HOME/applications/my_app.desktop
"#;
    fs::write(path, symlist_template)?;
    Ok(())
}

/// Loads a symlink list from `symlist` file
///
/// - `path` — path to the symlist file
/// - `package_root` — root directory of the package
///
/// Returns a vector of `(source_path, target_path)`.
///
/// # Errors
/// - [`SymlistError::Io`] — if the file cannot be read
/// - [`SymlistError::Parse`] — if the file has an invalid format
///
/// # Example
/// ```no_run
/// use uhpm::symlist::load_symlist;
/// use std::path::Path;
///
/// let symlinks = load_symlist(Path::new("symlist"), Path::new("/tmp/pkg_root")).unwrap();
/// for (src, dst) in symlinks {
///     println!("{} -> {}", src.display(), dst.display());
/// }
/// ```
pub fn load_symlist(
    path: &Path,
    package_root: &Path,
) -> Result<Vec<(PathBuf, PathBuf)>, SymlistError> {
    let content = fs::read_to_string(path)?;

    let mut entries = Vec::new();

    for (line_num, line) in content.lines().enumerate() {
        match parse_symlist_line(line) {
            Ok(entry) => entries.push(entry),
            Err(SymlistError::Parse(msg)) if msg.contains("Empty or comment") => {
                // Skip empty lines and comments
                continue;
            }
            Err(e) => {
                return Err(SymlistError::Parse(format!("Line {}: {}", line_num + 1, e)));
            }
        }
    }

    Ok(entries
        .into_iter()
        .map(|e| {
            let src = package_root.join(e.source);
            let dst = expand_vars(&e.target);
            (src, dst)
        })
        .collect())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::path::PathBuf;
    use tempfile::tempdir;

    #[test]
    fn test_expand_vars_home() {
        let home = dirs::home_dir().unwrap();
        let path = "$HOME/test_folder";
        let expanded = expand_vars(path);
        assert_eq!(expanded, home.join("test_folder"));
    }

    #[test]
    fn test_expand_vars_xdg() {
        let home = dirs::home_dir().unwrap();
        let xdg_data = std::env::var("XDG_DATA_HOME")
            .unwrap_or_else(|_| format!("{}/.local/share", home.to_string_lossy()));
        let path = "$XDG_DATA_HOME/some_dir";
        let expanded = expand_vars(path);
        assert_eq!(expanded, PathBuf::from(xdg_data).join("some_dir"));
    }

    #[test]
    fn test_parse_symlist_line() {
        let line = "/package/bin/foo $HOME/.local/bin/foo";
        let entry = parse_symlist_line(line).unwrap();
        assert_eq!(entry.source, "/package/bin/foo");
        assert_eq!(entry.target, "$HOME/.local/bin/foo");

        // Test with multiple spaces
        let line = "/package/bin/foo    $HOME/.local/bin/foo";
        let entry = parse_symlist_line(line).unwrap();
        assert_eq!(entry.source, "/package/bin/foo");
        assert_eq!(entry.target, "$HOME/.local/bin/foo");
    }

    #[test]
    fn test_parse_symlist_line_invalid() {
        // Missing target
        let line = "/package/bin/foo";
        assert!(parse_symlist_line(line).is_err());

        // Empty line
        let line = "";
        assert!(parse_symlist_line(line).is_err());

        // Comment line
        let line = "# This is a comment";
        assert!(parse_symlist_line(line).is_err());
    }

    #[test]
    fn test_load_symlist_parsing() {
        let tmp_dir = tempdir().unwrap();
        let symlist_path = tmp_dir.path().join("symlist");

        let content = r#"# This is a comment line

bin/foo $HOME/.local/bin/foo
config/bar $XDG_CONFIG_HOME/bar

# Another comment
share/data $XDG_DATA_HOME/app_data
"#;
        fs::write(&symlist_path, content).unwrap();

        let package_root = tmp_dir.path();
        let symlinks = load_symlist(&symlist_path, package_root).unwrap();

        assert_eq!(symlinks.len(), 3);

        assert_eq!(symlinks[0].0, package_root.join("bin/foo"));
        assert_eq!(symlinks[1].0, package_root.join("config/bar"));
        assert_eq!(symlinks[2].0, package_root.join("share/data"));

        assert!(symlinks[0].1.to_string_lossy().ends_with(".local/bin/foo"));
        assert!(symlinks[1].1.to_string_lossy().ends_with("bar"));
        assert!(symlinks[2].1.to_string_lossy().ends_with("app_data"));
    }
}
############### ENDOFFILE ########################

############### cli.rs #########################
use crate::self_remove;
use crate::service::PackageService;
use crate::{error, info, lprintln};
use clap::CommandFactory;
use clap::{Parser, Subcommand};
use clap_complete::{
    generate,
    shells::{Bash, Fish, Zsh},
};
use std::io;
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "uhpm", version, about = "Universal Home Package Manager")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    Install {
        #[arg(short, long)]
        file: Option<PathBuf>,
        #[arg(value_name = "PACKAGE")]
        package: Vec<String>,
        #[arg(short, long)]
        version: Option<String>,
    },
    Remove {
        #[arg(value_name = "PACKAGE")]
        packages: Vec<String>,
    },
    List,
    SelfRemove,
    Update {
        #[arg(short, long)]
        file: Option<PathBuf>,
        #[arg(value_name = "PACKAGE")]
        packages: Vec<String>,
    },
    Switch {
        #[arg(value_name = "PACKAGE@VERSION")]
        target: String,
    },
    Completions {
        shell: String,
    },
}

impl Cli {
    pub async fn run(&self, service: &PackageService) -> Result<(), Box<dyn std::error::Error>> {
        match &self.command {
            Commands::Install {
                file,
                package,
                version,
            } => {
                if let Some(path) = file {
                    info!("cli.install.from_file", path.display());
                    service.install_from_file(path).await?;
                } else if !package.is_empty() {
                    for pkg_name in package {
                        info!("cli.install.from_repo", pkg_name);
                        service
                            .install_from_repo(pkg_name, version.as_deref())
                            .await?;
                    }
                } else {
                    error!("cli.install.no_file_or_package");
                }
            }

            Commands::Remove { packages } => {
                if packages.is_empty() {
                    error!("cli.remove.no_packages");
                } else {
                    for pkg_name in packages {
                        if pkg_name.contains('@') {
                            let parts: Vec<&str> = pkg_name.split('@').collect();
                            if parts.len() == 2 {
                                let (pkg_name, pkg_version) = (parts[0], parts[1]);
                                info!("cli.remove.parts", pkg_name, pkg_version);
                                service
                                    .remove_package_version(pkg_name, pkg_version)
                                    .await?;
                            } else {
                                error!("cli.remove.invalid_format", pkg_name);
                            }
                        } else {
                            info!("cli.remove.removing", pkg_name);
                            service.remove_package(pkg_name).await?;
                        }
                    }
                }
            }

            Commands::List => {
                let packages = service.list_packages().await?;
                if packages.is_empty() {
                    lprintln!("cli.list.no_packages");
                } else {
                    lprintln!("cli.list.installed_packages");
                    for (name, version, current) in packages {
                        let marker = if current { '*' } else { ' ' };
                        lprintln!("cli.list.package_format", name, version, marker);
                    }
                }
            }

            Commands::Update { file, packages } => {
                if let Some(path) = file {
                    info!("cli.update.from_file", path.display());
                    service.install_from_file(path).await?;
                } else {
                    for package in packages {
                        match service.update_package(package).await {
                            Ok(()) => info!("cli.update.success", package),
                            Err(e) => error!("cli.update.error", package, e),
                        }
                    }
                }
            }

            Commands::Switch { target } => {
                let parts: Vec<&str> = target.split('@').collect();
                if parts.len() != 2 {
                    error!("cli.switch.invalid_format", target);
                    return Ok(());
                }

                let pkg_name = parts[0];
                let pkg_version = parts[1];

                match semver::Version::parse(pkg_version) {
                    Ok(version) => {
                        info!("cli.switch.switching", pkg_name, pkg_version);
                        service.switch_version(pkg_name, version).await?;
                        info!("cli.switch.success", pkg_name, pkg_version);
                    }
                    Err(e) => {
                        error!("cli.switch.invalid_version", pkg_version, e);
                    }
                }
            }

            Commands::SelfRemove => {
                self_remove::self_remove()?;
            }

            Commands::Completions { shell } => match shell.to_lowercase().as_str() {
                "bash" => generate(Bash, &mut Cli::command(), "uhpm", &mut io::stdout()),
                "zsh" => generate(Zsh, &mut Cli::command(), "uhpm", &mut io::stdout()),
                "fish" => generate(Fish, &mut Cli::command(), "uhpm", &mut io::stdout()),
                other => println!("Unsupported shell: {}", other),
            },
        }

        Ok(())
    }
}
############### ENDOFFILE ########################

############### main.rs #########################
use clap::Parser;
use dirs;
use uhpm::cli::Cli;
use uhpm::db::PackageDB;
use uhpm::service::PackageService;
use uhpm::{debug, info};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt::init();

    let mut db_path = dirs::home_dir().ok_or("Could not determine home directory")?;
    db_path.push(".uhpm");
    db_path.push("packages.db");

    debug!("main.info.using_package_db");
    debug!("main.info.db_path_is", db_path.display());

    let package_db = PackageDB::new(&db_path)?.init().await?;
    let package_service = PackageService::new(package_db);

    info!("main.info.uhpm_started");

    let args = Cli::parse();
    args.run(&package_service).await?;

    Ok(())
}
############### ENDOFFILE ########################

############### service.rs #########################
use crate::db::PackageDB;
use crate::error::{ConfigError, UhpmError};
use crate::fetcher;
use crate::package::{installer, remover, switcher, updater};
use crate::repo::{RepoDB, parse_repos};
use semver::Version;
use std::path::{Path, PathBuf};

pub struct PackageService {
    db: PackageDB,
}

impl PackageService {
    pub fn new(db: PackageDB) -> Self {
        Self { db }
    }

    pub async fn install_from_file(&self, path: &Path) -> Result<(), UhpmError> {
        installer::install(path, &self.db).await?;
        Ok(())
    }

    pub async fn install_from_repo(
        &self,
        package_name: &str,
        version: Option<&str>,
    ) -> Result<(), UhpmError> {
        let repos = self.load_repositories().await?;
        let mut urls_to_download = Vec::new();

        for (repo_name, repo_path) in &repos {
            let repo_db_path = self.get_repo_db_path(repo_path)?;
            if !repo_db_path.exists() {
                tracing::warn!("Repository database not found: {}", repo_name);
                continue;
            }

            let repo_db = RepoDB::new(&repo_db_path).await?;
            let packages = repo_db.list_packages().await?;

            for (name, pkg_version) in packages {
                if name == package_name {
                    if version.is_none() || version.unwrap() == pkg_version {
                        if let Ok(url) = repo_db.get_package(&name, &pkg_version).await {
                            urls_to_download.push(url);
                            break;
                        }
                    }
                }
            }
        }

        if urls_to_download.is_empty() {
            return Err(UhpmError::NotFound(format!(
                "Package {} not found in repositories",
                package_name
            )));
        }

        fetcher::fetch_and_install_parallel(&urls_to_download, &self.db).await?;
        Ok(())
    }

    pub async fn remove_package(&self, package_name: &str) -> Result<(), UhpmError> {
        remover::remove(package_name, &self.db).await?;
        Ok(())
    }

    pub async fn remove_package_version(
        &self,
        package_name: &str,
        version: &str,
    ) -> Result<(), UhpmError> {
        remover::remove_by_version(package_name, version, &self.db).await?;
        Ok(())
    }

    pub async fn update_package(&self, package_name: &str) -> Result<(), UhpmError> {
        updater::update_package(package_name, &self.db).await?;
        Ok(())
    }

    pub async fn switch_version(
        &self,
        package_name: &str,
        version: Version,
    ) -> Result<(), UhpmError> {
        switcher::switch_version(package_name, version, &self.db).await?;
        Ok(())
    }

    pub async fn list_packages(&self) -> Result<Vec<(String, String, bool)>, UhpmError> {
        self.db.list_packages().await.map_err(UhpmError::from)
    }

    async fn load_repositories(
        &self,
    ) -> Result<std::collections::HashMap<String, String>, UhpmError> {
        let repos_path = dirs::home_dir()
            .ok_or_else(|| {
                UhpmError::Config(ConfigError::NotFound(
                    "Home directory not found".to_string(),
                ))
            })?
            .join(".uhpm/repos.ron");

        parse_repos(&repos_path).map_err(|e| UhpmError::Repository(e.into()))
    }

    fn get_repo_db_path(&self, repo_path: &str) -> Result<PathBuf, UhpmError> {
        let path = if let Some(stripped) = repo_path.strip_prefix("file://") {
            stripped
        } else {
            repo_path
        };
        Ok(PathBuf::from(path).join("packages.db"))
    }
}
############### ENDOFFILE ########################

